// *********************************************************
// *                                                       *
// *   Copyright (C) Microsoft. All rights reserved.       *
// *                                                       *
// *********************************************************

//----------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Input Grammar      : SarifGrammar
//     Input Grammar file : D:\src\sarif-sdk-ms\src\StaticAnalysisResultsInterchangeFormat\GrammarFiles\Sarif.g4
//     
//     Changes to this file may cause incorrect behavior and 
//     will be lost when the code is regenerated.
// </auto-generated>
//----------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Text;

namespace Microsoft.CodeAnalysis.StaticAnalysisResultsInterchangeFormat.DataContracts
{
    /// <summary>An enumeration containing all the types which implement <see cref="ISyntax" />.</summary>
    public enum SarifGrammarKind
    {
        /// <summary>An uninitialized kind.</summary>
        None,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type AnnotatedCodeLocation.</summary>
        AnnotatedCodeLocation,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type FileChange.</summary>
        FileChange,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type FileReference.</summary>
        FileReference,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type Fix.</summary>
        Fix,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type FormattedMessage.</summary>
        FormattedMessage,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type Hash.</summary>
        Hash,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type Location.</summary>
        Location,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type LogicalLocationComponent.</summary>
        LogicalLocationComponent,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type PhysicalLocationComponent.</summary>
        PhysicalLocationComponent,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type Region.</summary>
        Region,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type Replacement.</summary>
        Replacement,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type Result.</summary>
        Result,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type ResultLog.</summary>
        ResultLog,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type RuleDescriptor.</summary>
        RuleDescriptor,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type RunInfo.</summary>
        RunInfo,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type RunLog.</summary>
        RunLog,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type ToolInfo.</summary>
        ToolInfo,
    }

    /// <summary>An interface for all types generated from the grammar SarifGrammar.</summary>
    public interface ISyntax
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        SarifGrammarKind SyntaxKind { get; }

        /// <summary>Makes a deep copy of this instance.</summary>
        ISyntax DeepClone();
    }

    [DataContract]
    [CompilerGenerated]
    public enum AlgorithmKind
    {
        Unknown = 0,
        Blake256,
        Blake512,
        Ecoh,
        Fsb,
        Gost,
        Groestl,
        Has160,
        Haval,
        JH,
        MD2,
        MD4,
        MD5,
        MD6,
        RadioGatun,
        RipeMd,
        RipeMd128,
        RipeMd160,
        RipeMd320,
        Sha1,
        Sha224,
        Sha256,
        Sha384,
        Sha512,
        Sha3,
        Skein,
        Snefru,
        SpectralHas,
        Swifft,
        Tiger,
        Whirlpool,
    }

    /// <summary>
    /// A code annotation that consists of single physical location and associated message, used to express
    /// stacks, execution flow through a method, or other locations that are related to a result.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class AnnotatedCodeLocation : ISyntax, IEquatable<AnnotatedCodeLocation>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public SarifGrammarKind SyntaxKind { get { return SarifGrammarKind.AnnotatedCodeLocation; } }

        /// <summary>
        /// A code location to which this annotation refers.
        /// </summary>
        [DataMember(Name="physicalLocation", IsRequired = true)]
        public IList<PhysicalLocationComponent> PhysicalLocation { get; set; }

        /// <summary>
        /// A message associated with this annotation, if applicable.
        /// </summary>
        [DataMember(Name="message", IsRequired = false, EmitDefaultValue = false)]
        public string Message { get; set; }

        private void Init(IEnumerable<PhysicalLocationComponent> physicalLocationArg, string messageArg)
        {
            if (physicalLocationArg != null)
            {
                var destination_0 = new List<PhysicalLocationComponent>();
                if (physicalLocationArg != null)
                {
                    foreach (var value_0 in physicalLocationArg)
                    {
                        if (value_0 == null)
                        {
                            destination_0.Add(null);
                        }
                        else
                        {
                            destination_0.Add(new PhysicalLocationComponent(value_0));
                        }
                    }
                }

                this.PhysicalLocation = destination_0;
            }
            if (messageArg != null)
            {
                this.Message = messageArg;
            }
        }

        /// <summary>Initializes a new instance of the <see cref="AnnotatedCodeLocation" /> class.</summary>
        public AnnotatedCodeLocation()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="AnnotatedCodeLocation" /> class with the supplied data.</summary>
        /// <param name="physicalLocationArg">An initialization value for the <see cref="P:PhysicalLocation" /> member.</param>
        /// <param name="messageArg">An initialization value for the <see cref="P:Message" /> member.</param>
        public AnnotatedCodeLocation(IEnumerable<PhysicalLocationComponent> physicalLocationArg, string messageArg)
        {
            this.Init(
                physicalLocationArg, 
                messageArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="AnnotatedCodeLocation" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public AnnotatedCodeLocation(AnnotatedCodeLocation other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.PhysicalLocation, 
                other.Message
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public AnnotatedCodeLocation DeepClone()
        {
            return (AnnotatedCodeLocation)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new AnnotatedCodeLocation(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                foreach (var value_0 in this.PhysicalLocation)
                {
                    result = result * 31;
                    if (value_0 != null)
                    {
                        result = (result * 31) + value_0.GetHashCode();
                    }
                }

                if (this.Message != null)
                {
                    result = (result * 31) + this.Message.GetHashCode();
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as AnnotatedCodeLocation);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(AnnotatedCodeLocation other)
        {
            if (other == null)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.PhysicalLocation, other.PhysicalLocation))
            {
                if (this.PhysicalLocation == null || other.PhysicalLocation == null)
                {
                    return false;
                }

                if (this.PhysicalLocation.Count != other.PhysicalLocation.Count)
                {
                    return false;
                }

                int max_0 = this.PhysicalLocation.Count;
                for (int index_0 = 0; index_0 < max_0; ++index_0)
                {
                    var value_1 = this.PhysicalLocation[index_0];
                    var value_2 = other.PhysicalLocation[index_0];
                    if (!global::System.Object.Equals(value_1, value_2))
                    {
                        return false;
                    }
                }
            }

            if (this.Message != other.Message)
            {
                return false;
            }

            return true;
        }
    }

    /// <summary>
    /// A change to a single file.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class FileChange : ISyntax, IEquatable<FileChange>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public SarifGrammarKind SyntaxKind { get { return SarifGrammarKind.FileChange; } }

        /// <summary>
        /// A string that represents the location of the file to change as a valid URI.
        /// </summary>
        [DataMember(Name="uri", IsRequired = true)]
        public global::System.Uri Uri { get; set; }

        /// <summary>
        /// An array of replacement objects, each of which represents the replacement of a single range of
        /// bytes in a single file specified by the uri property.
        /// </summary>
        [DataMember(Name="replacements", IsRequired = true)]
        public IList<Replacement> Replacements { get; set; }

        private void Init(global::System.Uri uriArg, IEnumerable<Replacement> replacementsArg)
        {
            if (uriArg != null)
            {
                this.Uri = new global::System.Uri(uriArg.OriginalString, uriArg.IsAbsoluteUri ? global::System.UriKind.Absolute : global::System.UriKind.Relative);
            }
            if (replacementsArg != null)
            {
                var destination_0 = new List<Replacement>();
                if (replacementsArg != null)
                {
                    foreach (var value_0 in replacementsArg)
                    {
                        if (value_0 == null)
                        {
                            destination_0.Add(null);
                        }
                        else
                        {
                            destination_0.Add(new Replacement(value_0));
                        }
                    }
                }

                this.Replacements = destination_0;
            }
        }

        /// <summary>Initializes a new instance of the <see cref="FileChange" /> class.</summary>
        public FileChange()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="FileChange" /> class with the supplied data.</summary>
        /// <param name="uriArg">An initialization value for the <see cref="P:Uri" /> member.</param>
        /// <param name="replacementsArg">An initialization value for the <see cref="P:Replacements" /> member.</param>
        public FileChange(global::System.Uri uriArg, IEnumerable<Replacement> replacementsArg)
        {
            this.Init(
                uriArg, 
                replacementsArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="FileChange" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public FileChange(FileChange other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.Uri, 
                other.Replacements
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public FileChange DeepClone()
        {
            return (FileChange)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new FileChange(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                if (this.Uri != null)
                {
                    result = (result * 31) + this.Uri.GetHashCode();
                }
                foreach (var value_0 in this.Replacements)
                {
                    result = result * 31;
                    if (value_0 != null)
                    {
                        result = (result * 31) + value_0.GetHashCode();
                    }
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as FileChange);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(FileChange other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.Uri != other.Uri)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.Replacements, other.Replacements))
            {
                if (this.Replacements == null || other.Replacements == null)
                {
                    return false;
                }

                if (this.Replacements.Count != other.Replacements.Count)
                {
                    return false;
                }

                int max_0 = this.Replacements.Count;
                for (int index_0 = 0; index_0 < max_0; ++index_0)
                {
                    var value_1 = this.Replacements[index_0];
                    var value_2 = other.Replacements[index_0];
                    if (!global::System.Object.Equals(value_1, value_2))
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }

    /// <summary>
    /// A fileReference object represents a single file
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class FileReference : ISyntax, IEquatable<FileReference>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public SarifGrammarKind SyntaxKind { get { return SarifGrammarKind.FileReference; } }

        /// <summary>
        /// The location of the file as a valid URI
        /// </summary>
        [DataMember(Name="uri", IsRequired = true)]
        public global::System.Uri Uri { get; set; }

        /// <summary>
        /// An optional array of hash objects, each of which specifies a hashed value for the file specified
        /// by the uri property, along with the name of the algorithm used to compute the hash.
        /// </summary>
        [DataMember(Name="hashes", IsRequired = false, EmitDefaultValue = false)]
        public IList<Hash> Hashes { get; set; }

        private void Init(global::System.Uri uriArg, IEnumerable<Hash> hashesArg)
        {
            if (uriArg != null)
            {
                this.Uri = new global::System.Uri(uriArg.OriginalString, uriArg.IsAbsoluteUri ? global::System.UriKind.Absolute : global::System.UriKind.Relative);
            }
            if (hashesArg != null)
            {
                var destination_0 = new List<Hash>();
                if (hashesArg != null)
                {
                    foreach (var value_0 in hashesArg)
                    {
                        if (value_0 == null)
                        {
                            destination_0.Add(null);
                        }
                        else
                        {
                            destination_0.Add(new Hash(value_0));
                        }
                    }
                }

                this.Hashes = destination_0;
            }
        }

        /// <summary>Initializes a new instance of the <see cref="FileReference" /> class.</summary>
        public FileReference()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="FileReference" /> class with the supplied data.</summary>
        /// <param name="uriArg">An initialization value for the <see cref="P:Uri" /> member.</param>
        /// <param name="hashesArg">An initialization value for the <see cref="P:Hashes" /> member.</param>
        public FileReference(global::System.Uri uriArg, IEnumerable<Hash> hashesArg)
        {
            this.Init(
                uriArg, 
                hashesArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="FileReference" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public FileReference(FileReference other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.Uri, 
                other.Hashes
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public FileReference DeepClone()
        {
            return (FileReference)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new FileReference(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                if (this.Uri != null)
                {
                    result = (result * 31) + this.Uri.GetHashCode();
                }
                foreach (var value_0 in this.Hashes)
                {
                    result = result * 31;
                    if (value_0 != null)
                    {
                        result = (result * 31) + value_0.GetHashCode();
                    }
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as FileReference);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(FileReference other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.Uri != other.Uri)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.Hashes, other.Hashes))
            {
                if (this.Hashes == null || other.Hashes == null)
                {
                    return false;
                }

                if (this.Hashes.Count != other.Hashes.Count)
                {
                    return false;
                }

                int max_0 = this.Hashes.Count;
                for (int index_0 = 0; index_0 < max_0; ++index_0)
                {
                    var value_1 = this.Hashes[index_0];
                    var value_2 = other.Hashes[index_0];
                    if (!global::System.Object.Equals(value_1, value_2))
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }

    /// <summary>
    /// A proposed fix an a code defect represented by a result object. A fix specifies a set of file to modify.
    /// For each file, the fix specifies a set of bytes to remove and provides a set of new bytes to replace them.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class Fix : ISyntax, IEquatable<Fix>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public SarifGrammarKind SyntaxKind { get { return SarifGrammarKind.Fix; } }

        /// <summary>
        /// A string that describes the proposed fix, enabling viewers to present a proposed change to an end user.
        /// </summary>
        [DataMember(Name="description", IsRequired = true)]
        public string Description { get; set; }

        /// <summary>
        /// A message associated with this annotation, if applicable.
        /// </summary>
        [DataMember(Name="fileChanges", IsRequired = true)]
        public IList<FileChange> FileChanges { get; set; }

        private void Init(string descriptionArg, IEnumerable<FileChange> fileChangesArg)
        {
            if (descriptionArg != null)
            {
                this.Description = descriptionArg;
            }
            if (fileChangesArg != null)
            {
                var destination_0 = new List<FileChange>();
                if (fileChangesArg != null)
                {
                    foreach (var value_0 in fileChangesArg)
                    {
                        if (value_0 == null)
                        {
                            destination_0.Add(null);
                        }
                        else
                        {
                            destination_0.Add(new FileChange(value_0));
                        }
                    }
                }

                this.FileChanges = destination_0;
            }
        }

        /// <summary>Initializes a new instance of the <see cref="Fix" /> class.</summary>
        public Fix()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="Fix" /> class with the supplied data.</summary>
        /// <param name="descriptionArg">An initialization value for the <see cref="P:Description" /> member.</param>
        /// <param name="fileChangesArg">An initialization value for the <see cref="P:FileChanges" /> member.</param>
        public Fix(string descriptionArg, IEnumerable<FileChange> fileChangesArg)
        {
            this.Init(
                descriptionArg, 
                fileChangesArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="Fix" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public Fix(Fix other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.Description, 
                other.FileChanges
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public Fix DeepClone()
        {
            return (Fix)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new Fix(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                if (this.Description != null)
                {
                    result = (result * 31) + this.Description.GetHashCode();
                }
                foreach (var value_0 in this.FileChanges)
                {
                    result = result * 31;
                    if (value_0 != null)
                    {
                        result = (result * 31) + value_0.GetHashCode();
                    }
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as Fix);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(Fix other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.Description != other.Description)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.FileChanges, other.FileChanges))
            {
                if (this.FileChanges == null || other.FileChanges == null)
                {
                    return false;
                }

                if (this.FileChanges.Count != other.FileChanges.Count)
                {
                    return false;
                }

                int max_0 = this.FileChanges.Count;
                for (int index_0 = 0; index_0 < max_0; ++index_0)
                {
                    var value_1 = this.FileChanges[index_0];
                    var value_2 = other.FileChanges[index_0];
                    if (!global::System.Object.Equals(value_1, value_2))
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }

    /// <summary>
    /// A formatted message object encapsulates information that can be used to construct a
    /// fully formatted message that describes an issue.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class FormattedMessage : ISyntax, IEquatable<FormattedMessage>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public SarifGrammarKind SyntaxKind { get { return SarifGrammarKind.FormattedMessage; } }

        /// <summary>
        /// A string that identifies the format string used to format the message that describes
        /// this result. The value of specifierId must correspond to one of the names in the set
        /// of name/value pairs contained in the format specifiers property of the rule info
        /// object whose id property matches the rule id property of this issue.
        /// </summary>
        [DataMember(Name="specifierId", IsRequired = true)]
        public string SpecifierId { get; set; }

        /// <summary>
        /// An array of string values that will be used, in combination with a format specifier,
        /// to construct a result message.
        /// </summary>
        [DataMember(Name="arguments", IsRequired = true)]
        public IList<string> Arguments { get; set; }

        private void Init(string specifierIdArg, IEnumerable<string> argumentsArg)
        {
            if (specifierIdArg != null)
            {
                this.SpecifierId = specifierIdArg;
            }
            if (argumentsArg != null)
            {
                var destination_0 = new List<string>();
                if (argumentsArg != null)
                {
                    foreach (var value_0 in argumentsArg)
                    {
                        if (value_0 == null)
                        {
                            destination_0.Add(null);
                        }
                        else
                        {
                            destination_0.Add(value_0);
                        }
                    }
                }

                this.Arguments = destination_0;
            }
        }

        /// <summary>Initializes a new instance of the <see cref="FormattedMessage" /> class.</summary>
        public FormattedMessage()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="FormattedMessage" /> class with the supplied data.</summary>
        /// <param name="specifierIdArg">An initialization value for the <see cref="P:SpecifierId" /> member.</param>
        /// <param name="argumentsArg">An initialization value for the <see cref="P:Arguments" /> member.</param>
        public FormattedMessage(string specifierIdArg, IEnumerable<string> argumentsArg)
        {
            this.Init(
                specifierIdArg, 
                argumentsArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="FormattedMessage" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public FormattedMessage(FormattedMessage other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.SpecifierId, 
                other.Arguments
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public FormattedMessage DeepClone()
        {
            return (FormattedMessage)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new FormattedMessage(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                if (this.SpecifierId != null)
                {
                    result = (result * 31) + this.SpecifierId.GetHashCode();
                }
                foreach (var value_0 in this.Arguments)
                {
                    result = result * 31;
                    if (value_0 != null)
                    {
                        result = (result * 31) + value_0.GetHashCode();
                    }
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as FormattedMessage);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(FormattedMessage other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.SpecifierId != other.SpecifierId)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.Arguments, other.Arguments))
            {
                if (this.Arguments == null || other.Arguments == null)
                {
                    return false;
                }

                if (this.Arguments.Count != other.Arguments.Count)
                {
                    return false;
                }

                int max_0 = this.Arguments.Count;
                for (int index_0 = 0; index_0 < max_0; ++index_0)
                {
                    var value_1 = this.Arguments[index_0];
                    var value_2 = other.Arguments[index_0];
                    if (value_1 != value_2)
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }

    /// <summary>
    /// A hash value of some file or collection of files, together with the algorithm used to compute the hash.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class Hash : ISyntax, IEquatable<Hash>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public SarifGrammarKind SyntaxKind { get { return SarifGrammarKind.Hash; } }

        /// <summary>
        /// The hash value of some file or collection of files, computed by the algorithm named in the algorithm property.
        /// </summary>
        [DataMember(Name="value", IsRequired = true)]
        public string Value { get; set; }

        /// <summary>
        /// A string specifying the name of the algorithm used to compute the hash value specified in the value property.
        /// This shall be one of the following: BLAKE-256, BLAKE-512, ECOH, FSB, GOST, Groestl, HAS-160, HAVAL, JH, MD2,
        /// MD4, MD5, MD6, RadioGatun, RIPEMD, RIPEMD-128, RIPEMD-160, RIPEMD-320, SHA-1, SHA-224, SHA-256, SHA-384,
        /// SHA-512, SHA-3, Skein, Snefru, Spectral Hash, SWIFFT, Tiger, Whirlpool.
        /// </summary>
        [DataMember(Name="algorithm", IsRequired = true)]
        public AlgorithmKind Algorithm { get; set; }

        private void Init(string valueArg, AlgorithmKind algorithmArg)
        {
            if (valueArg != null)
            {
                this.Value = valueArg;
            }
            this.Algorithm = algorithmArg;
        }

        /// <summary>Initializes a new instance of the <see cref="Hash" /> class.</summary>
        public Hash()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="Hash" /> class with the supplied data.</summary>
        /// <param name="valueArg">An initialization value for the <see cref="P:Value" /> member.</param>
        /// <param name="algorithmArg">An initialization value for the <see cref="P:Algorithm" /> member.</param>
        public Hash(string valueArg, AlgorithmKind algorithmArg)
        {
            this.Init(
                valueArg, 
                algorithmArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="Hash" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public Hash(Hash other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.Value, 
                other.Algorithm
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public Hash DeepClone()
        {
            return (Hash)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new Hash(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                if (this.Value != null)
                {
                    result = (result * 31) + this.Value.GetHashCode();
                }
                result = (result * 31) + (int)this.Algorithm;
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as Hash);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(Hash other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.Value != other.Value)
            {
                return false;
            }

            if (this.Algorithm != other.Algorithm)
            {
                return false;
            }

            return true;
        }
    }

    /// <summary>
    /// Specifies a location within a file, or within an object nested within a file
    /// (such as a location within an assembly contained in an appx file).
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class Location : ISyntax, IEquatable<Location>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public SarifGrammarKind SyntaxKind { get { return SarifGrammarKind.Location; } }

        /// <summary>
        /// A source file that is associated with the item that the static analysis tool scanned. This
        /// may be a .dll in the case of a binary analysis tool like FxCop, or a C++ file in the case
        /// of a source analysis tool like PREfast. Note that the defect may not actually occur in this file.
        /// </summary>
        [DataMember(Name="analysisTarget", IsRequired = false, EmitDefaultValue = false)]
        public IList<PhysicalLocationComponent> AnalysisTarget { get; set; }

        /// <summary>
        /// A source file that is associated with the current result if and only if that is not the
        /// same as the analysis target. This member will populated or not, in many cases, depending
        /// on whether PDBs associated with the analysis target are available. Examples include a C# file
        /// in the FxCop-like binary analysis case, or possibly a .H C++ file in the case of a source
        /// analysis tool like PREfast.
        /// </summary>
        [DataMember(Name="resultFile", IsRequired = false, EmitDefaultValue = false)]
        public IList<PhysicalLocationComponent> ResultFile { get; set; }

        /// <summary>
        /// An object that specifies the logical location for which a result is produced.
        /// </summary>
        [DataMember(Name="logicalLocation", IsRequired = false, EmitDefaultValue = false)]
        public IList<LogicalLocationComponent> LogicalLocation { get; set; }

        /// <summary>
        /// A string containing the language-specific logical name of the location where the result occurs; e.g.
        ///     C: Foo
        ///     C++: Namespace::Class::MemberFunction(int, double) const&amp;&amp;
        ///     C++: Namespace::NonmemberFunction(int, double)
        ///     C#: SecurityCryptographyRuleTests.DESCannotBeUsed.EncryptData(System.String,System.String,System.Byte[],System.Byte[])
        /// </summary>
        [DataMember(Name="fullyQualifiedLogicalName", IsRequired = false, EmitDefaultValue = false)]
        public string FullyQualifiedLogicalName { get; set; }

        /// <summary>
        /// Key/value pairs that provide additional information about this location.
        /// This might be used to annotate specific stack frames or points in code
        /// with additional information, such as assumed values of variables at that
        /// point of execution, etc.
        /// </summary>
        [DataMember(Name="properties", IsRequired = false, EmitDefaultValue = false)]
        public global::System.Collections.Generic.Dictionary<string, string> Properties { get; set; }

        private void Init(IEnumerable<PhysicalLocationComponent> analysisTargetArg, IEnumerable<PhysicalLocationComponent> resultFileArg, IEnumerable<LogicalLocationComponent> logicalLocationArg, string fullyQualifiedLogicalNameArg, global::System.Collections.Generic.Dictionary<string, string> propertiesArg)
        {
            if (analysisTargetArg != null)
            {
                var destination_0 = new List<PhysicalLocationComponent>();
                if (analysisTargetArg != null)
                {
                    foreach (var value_0 in analysisTargetArg)
                    {
                        if (value_0 == null)
                        {
                            destination_0.Add(null);
                        }
                        else
                        {
                            destination_0.Add(new PhysicalLocationComponent(value_0));
                        }
                    }
                }

                this.AnalysisTarget = destination_0;
            }
            if (resultFileArg != null)
            {
                var destination_1 = new List<PhysicalLocationComponent>();
                if (resultFileArg != null)
                {
                    foreach (var value_1 in resultFileArg)
                    {
                        if (value_1 == null)
                        {
                            destination_1.Add(null);
                        }
                        else
                        {
                            destination_1.Add(new PhysicalLocationComponent(value_1));
                        }
                    }
                }

                this.ResultFile = destination_1;
            }
            if (logicalLocationArg != null)
            {
                var destination_2 = new List<LogicalLocationComponent>();
                if (logicalLocationArg != null)
                {
                    foreach (var value_2 in logicalLocationArg)
                    {
                        if (value_2 == null)
                        {
                            destination_2.Add(null);
                        }
                        else
                        {
                            destination_2.Add(new LogicalLocationComponent(value_2));
                        }
                    }
                }

                this.LogicalLocation = destination_2;
            }
            if (fullyQualifiedLogicalNameArg != null)
            {
                this.FullyQualifiedLogicalName = fullyQualifiedLogicalNameArg;
            }
            if (propertiesArg != null)
            {
                this.Properties = new global::System.Collections.Generic.Dictionary<string, string>(propertiesArg);
            }
        }

        /// <summary>Initializes a new instance of the <see cref="Location" /> class.</summary>
        public Location()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="Location" /> class with the supplied data.</summary>
        /// <param name="analysisTargetArg">An initialization value for the <see cref="P:AnalysisTarget" /> member.</param>
        /// <param name="resultFileArg">An initialization value for the <see cref="P:ResultFile" /> member.</param>
        /// <param name="logicalLocationArg">An initialization value for the <see cref="P:LogicalLocation" /> member.</param>
        /// <param name="fullyQualifiedLogicalNameArg">An initialization value for the <see cref="P:FullyQualifiedLogicalName" /> member.</param>
        /// <param name="propertiesArg">An initialization value for the <see cref="P:Properties" /> member.</param>
        public Location(IEnumerable<PhysicalLocationComponent> analysisTargetArg, IEnumerable<PhysicalLocationComponent> resultFileArg, IEnumerable<LogicalLocationComponent> logicalLocationArg, string fullyQualifiedLogicalNameArg, global::System.Collections.Generic.Dictionary<string, string> propertiesArg)
        {
            this.Init(
                analysisTargetArg, 
                resultFileArg, 
                logicalLocationArg, 
                fullyQualifiedLogicalNameArg, 
                propertiesArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="Location" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public Location(Location other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.AnalysisTarget, 
                other.ResultFile, 
                other.LogicalLocation, 
                other.FullyQualifiedLogicalName, 
                other.Properties
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public Location DeepClone()
        {
            return (Location)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new Location(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                foreach (var value_0 in this.AnalysisTarget)
                {
                    result = result * 31;
                    if (value_0 != null)
                    {
                        result = (result * 31) + value_0.GetHashCode();
                    }
                }

                foreach (var value_1 in this.ResultFile)
                {
                    result = result * 31;
                    if (value_1 != null)
                    {
                        result = (result * 31) + value_1.GetHashCode();
                    }
                }

                foreach (var value_2 in this.LogicalLocation)
                {
                    result = result * 31;
                    if (value_2 != null)
                    {
                        result = (result * 31) + value_2.GetHashCode();
                    }
                }

                if (this.FullyQualifiedLogicalName != null)
                {
                    result = (result * 31) + this.FullyQualifiedLogicalName.GetHashCode();
                }
                if (this.Properties != null)
                {
                    // Use xor for dictionaries to be order-independent
                    int xor_0 = 0;
                    foreach (var value_3 in this.Properties)
                    {
                        xor_0 ^= (value_3.Key ?? String.Empty).GetHashCode();
                        xor_0 ^= (value_3.Value ?? String.Empty).GetHashCode();
                    }

                    result = (result * 31) + xor_0;
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as Location);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(Location other)
        {
            if (other == null)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.AnalysisTarget, other.AnalysisTarget))
            {
                if (this.AnalysisTarget == null || other.AnalysisTarget == null)
                {
                    return false;
                }

                if (this.AnalysisTarget.Count != other.AnalysisTarget.Count)
                {
                    return false;
                }

                int max_0 = this.AnalysisTarget.Count;
                for (int index_0 = 0; index_0 < max_0; ++index_0)
                {
                    var value_4 = this.AnalysisTarget[index_0];
                    var value_5 = other.AnalysisTarget[index_0];
                    if (!global::System.Object.Equals(value_4, value_5))
                    {
                        return false;
                    }
                }
            }

            if (!global::System.Object.ReferenceEquals(this.ResultFile, other.ResultFile))
            {
                if (this.ResultFile == null || other.ResultFile == null)
                {
                    return false;
                }

                if (this.ResultFile.Count != other.ResultFile.Count)
                {
                    return false;
                }

                int max_1 = this.ResultFile.Count;
                for (int index_1 = 0; index_1 < max_1; ++index_1)
                {
                    var value_6 = this.ResultFile[index_1];
                    var value_7 = other.ResultFile[index_1];
                    if (!global::System.Object.Equals(value_6, value_7))
                    {
                        return false;
                    }
                }
            }

            if (!global::System.Object.ReferenceEquals(this.LogicalLocation, other.LogicalLocation))
            {
                if (this.LogicalLocation == null || other.LogicalLocation == null)
                {
                    return false;
                }

                if (this.LogicalLocation.Count != other.LogicalLocation.Count)
                {
                    return false;
                }

                int max_2 = this.LogicalLocation.Count;
                for (int index_2 = 0; index_2 < max_2; ++index_2)
                {
                    var value_8 = this.LogicalLocation[index_2];
                    var value_9 = other.LogicalLocation[index_2];
                    if (!global::System.Object.Equals(value_8, value_9))
                    {
                        return false;
                    }
                }
            }

            if (this.FullyQualifiedLogicalName != other.FullyQualifiedLogicalName)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.Properties, other.Properties))
            {
                if (this.Properties == null || other.Properties == null || this.Properties.Count != other.Properties.Count)
                {
                    return false;
                }
                foreach (var value_10 in this.Properties)
                {
                    string value_11;
                    if (!other.Properties.TryGetValue(value_10.Key, out value_11) || !global::System.Object.Equals(value_10.Value, value_11))
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }

    /// <summary>
    /// One level (e.g. namespace, function, etc.) of a logical location tree.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class LogicalLocationComponent : ISyntax, IEquatable<LogicalLocationComponent>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public SarifGrammarKind SyntaxKind { get { return SarifGrammarKind.LogicalLocationComponent; } }

        /// <summary>
        /// Name of the item specified by this location component.
        /// </summary>
        [DataMember(Name="name", IsRequired = true)]
        public string Name { get; set; }

        /// <summary>
        /// The type of item this location refers to.
        /// </summary>
        [DataMember(Name="kind", IsRequired = false, EmitDefaultValue = false)]
        public string Kind { get; set; }

        private void Init(string nameArg, string kindArg)
        {
            if (nameArg != null)
            {
                this.Name = nameArg;
            }
            if (kindArg != null)
            {
                this.Kind = kindArg;
            }
        }

        /// <summary>Initializes a new instance of the <see cref="LogicalLocationComponent" /> class.</summary>
        public LogicalLocationComponent()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="LogicalLocationComponent" /> class with the supplied data.</summary>
        /// <param name="nameArg">An initialization value for the <see cref="P:Name" /> member.</param>
        /// <param name="kindArg">An initialization value for the <see cref="P:Kind" /> member.</param>
        public LogicalLocationComponent(string nameArg, string kindArg)
        {
            this.Init(
                nameArg, 
                kindArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="LogicalLocationComponent" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public LogicalLocationComponent(LogicalLocationComponent other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.Name, 
                other.Kind
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public LogicalLocationComponent DeepClone()
        {
            return (LogicalLocationComponent)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new LogicalLocationComponent(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                if (this.Name != null)
                {
                    result = (result * 31) + this.Name.GetHashCode();
                }
                if (this.Kind != null)
                {
                    result = (result * 31) + this.Kind.GetHashCode();
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as LogicalLocationComponent);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(LogicalLocationComponent other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.Name != other.Name)
            {
                return false;
            }

            if (this.Kind != other.Kind)
            {
                return false;
            }

            return true;
        }
    }

    /// <summary>
    /// A part of a location that refers to a file.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class PhysicalLocationComponent : ISyntax, IEquatable<PhysicalLocationComponent>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public SarifGrammarKind SyntaxKind { get { return SarifGrammarKind.PhysicalLocationComponent; } }

        /// <summary>
        /// Uri to the file specified by this location.
        /// </summary>
        [DataMember(Name="uri", IsRequired = true)]
        public global::System.Uri Uri { get; set; }

        /// <summary>
        /// The MIME content type (RFC 2045) of the item referred to by this location.
        /// </summary>
        [DataMember(Name="mimeType", IsRequired = false, EmitDefaultValue = false)]
        public string MimeType { get; set; }

        /// <summary>
        /// The specific region within the analysis where the result was detected. This SHOULD only be
        /// set on the last physicalLocationComponent in a physicalLocation most of the time.
        /// (There are some exceptions e.g. an embedded .SWF in an Office 2003 format ppt)
        /// </summary>
        [DataMember(Name="region", IsRequired = false, EmitDefaultValue = false)]
        public Region Region { get; set; }

        private void Init(global::System.Uri uriArg, string mimeTypeArg, Region regionArg)
        {
            if (uriArg != null)
            {
                this.Uri = new global::System.Uri(uriArg.OriginalString, uriArg.IsAbsoluteUri ? global::System.UriKind.Absolute : global::System.UriKind.Relative);
            }
            if (mimeTypeArg != null)
            {
                this.MimeType = mimeTypeArg;
            }
            if (regionArg != null)
            {
                this.Region = new Region(regionArg);
            }
        }

        /// <summary>Initializes a new instance of the <see cref="PhysicalLocationComponent" /> class.</summary>
        public PhysicalLocationComponent()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="PhysicalLocationComponent" /> class with the supplied data.</summary>
        /// <param name="uriArg">An initialization value for the <see cref="P:Uri" /> member.</param>
        /// <param name="mimeTypeArg">An initialization value for the <see cref="P:MimeType" /> member.</param>
        /// <param name="regionArg">An initialization value for the <see cref="P:Region" /> member.</param>
        public PhysicalLocationComponent(global::System.Uri uriArg, string mimeTypeArg, Region regionArg)
        {
            this.Init(
                uriArg, 
                mimeTypeArg, 
                regionArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="PhysicalLocationComponent" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public PhysicalLocationComponent(PhysicalLocationComponent other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.Uri, 
                other.MimeType, 
                other.Region
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public PhysicalLocationComponent DeepClone()
        {
            return (PhysicalLocationComponent)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new PhysicalLocationComponent(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                if (this.Uri != null)
                {
                    result = (result * 31) + this.Uri.GetHashCode();
                }
                if (this.MimeType != null)
                {
                    result = (result * 31) + this.MimeType.GetHashCode();
                }
                if (this.Region != null)
                {
                    result = (result * 31) + this.Region.GetHashCode();
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as PhysicalLocationComponent);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(PhysicalLocationComponent other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.Uri != other.Uri)
            {
                return false;
            }

            if (this.MimeType != other.MimeType)
            {
                return false;
            }

            if (!global::System.Object.Equals(this.Region, other.Region))
            {
                return false;
            }

            return true;
        }
    }

    /// <summary>
    /// Specifies a region within a file where a result was detected.
    /// </summary>
    /// <remarks>
    /// Minimally, the Region should be populated with the StartLine or Offset members.
    /// There is some duplication of information in Region members. Log file producers
    /// are responsible for ensuring that any members populated in this type are
    /// consistent with each other (e.g., the file offset, if provided, should match the
    /// StartLine + EndColumn, if also provided). In the event that the type members are
    /// fully populated, viewers are free to choose whatever data is easiest to consume.
    /// </remarks>
    [DataContract]
    [CompilerGenerated]
    public sealed class Region : ISyntax, IEquatable<Region>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public SarifGrammarKind SyntaxKind { get { return SarifGrammarKind.Region; } }

        /// <summary>
        /// The starting line location associated with a region in the text file.
        /// </summary>
        [DataMember(Name="startLine", IsRequired = false, EmitDefaultValue = false)]
        public int StartLine { get; set; }

        /// <summary>
        /// The starting column location associated with a region in the text file.
        /// </summary>
        [DataMember(Name="startColumn", IsRequired = false, EmitDefaultValue = false)]
        public int StartColumn { get; set; }

        /// <summary>
        /// The ending line location associated with a region in the text file.
        /// </summary>
        [DataMember(Name="endLine", IsRequired = false, EmitDefaultValue = false)]
        public int EndLine { get; set; }

        /// <summary>
        /// The ending column location associated with a region in the text file.
        /// </summary>
        [DataMember(Name="endColumn", IsRequired = false, EmitDefaultValue = false)]
        public int EndColumn { get; set; }

        /// <summary>
        /// The zero-based offset into the file.
        /// </summary>
        [DataMember(Name="offset", IsRequired = false, EmitDefaultValue = false)]
        public int Offset { get; set; }

        /// <summary>
        /// The length of the region.
        /// </summary>
        [DataMember(Name="length", IsRequired = false, EmitDefaultValue = false)]
        public int Length { get; set; }

        private void Init(int startLineArg, int startColumnArg, int endLineArg, int endColumnArg, int offsetArg, int lengthArg)
        {
            this.StartLine = startLineArg;
            this.StartColumn = startColumnArg;
            this.EndLine = endLineArg;
            this.EndColumn = endColumnArg;
            this.Offset = offsetArg;
            this.Length = lengthArg;
        }

        /// <summary>Initializes a new instance of the <see cref="Region" /> class.</summary>
        public Region()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="Region" /> class with the supplied data.</summary>
        /// <param name="startLineArg">An initialization value for the <see cref="P:StartLine" /> member.</param>
        /// <param name="startColumnArg">An initialization value for the <see cref="P:StartColumn" /> member.</param>
        /// <param name="endLineArg">An initialization value for the <see cref="P:EndLine" /> member.</param>
        /// <param name="endColumnArg">An initialization value for the <see cref="P:EndColumn" /> member.</param>
        /// <param name="offsetArg">An initialization value for the <see cref="P:Offset" /> member.</param>
        /// <param name="lengthArg">An initialization value for the <see cref="P:Length" /> member.</param>
        public Region(int startLineArg, int startColumnArg, int endLineArg, int endColumnArg, int offsetArg, int lengthArg)
        {
            this.Init(
                startLineArg, 
                startColumnArg, 
                endLineArg, 
                endColumnArg, 
                offsetArg, 
                lengthArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="Region" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public Region(Region other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.StartLine, 
                other.StartColumn, 
                other.EndLine, 
                other.EndColumn, 
                other.Offset, 
                other.Length
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public Region DeepClone()
        {
            return (Region)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new Region(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                result = (result * 31) + (int)this.StartLine;
                result = (result * 31) + (int)this.StartColumn;
                result = (result * 31) + (int)this.EndLine;
                result = (result * 31) + (int)this.EndColumn;
                result = (result * 31) + (int)this.Offset;
                result = (result * 31) + (int)this.Length;
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as Region);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(Region other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.StartLine != other.StartLine)
            {
                return false;
            }

            if (this.StartColumn != other.StartColumn)
            {
                return false;
            }

            if (this.EndLine != other.EndLine)
            {
                return false;
            }

            if (this.EndColumn != other.EndColumn)
            {
                return false;
            }

            if (this.Offset != other.Offset)
            {
                return false;
            }

            if (this.Length != other.Length)
            {
                return false;
            }

            return true;
        }
    }

    /// <summary>
    /// The replacement of a single range of bytes in a file. Each instance specifies the location within
    /// the file where the replacement is to be made, the number of bytes to remove at that location, and
    /// a sequence of bytes to insert at that location.
    /// </summary>
    /// <remarks>
    /// If a replacement object specifies both the removal of a byte range by means of the deletedLength
    /// property and the insertion of a sequence of bytes by means of the insertedBytes property, then
    /// the effect of the replacment shall be as if the removal were performed before the insertion.
    /// If a single fileChange object specifies more than one replacement, then the effect of the
    /// replacements shall be as if they were performed in the order in which they appear in the
    /// replacements array. The offset property of each replacement shall specify an offset in the
    /// unmodified file (i.e., the offsets are not recomputed based on any prior changes to the file).
    /// </remarks>
    [DataContract]
    [CompilerGenerated]
    public sealed class Replacement : ISyntax, IEquatable<Replacement>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public SarifGrammarKind SyntaxKind { get { return SarifGrammarKind.Replacement; } }

        /// <summary>
        /// A non-negative integer specifying the offset in bytes from the beginning of the file at
        /// which bytes are to be removed, inserted or both. An offset of 0 shall denote the first
        /// byte in the file.
        /// </summary>
        [DataMember(Name="offset", IsRequired = true)]
        public int Offset { get; set; }

        /// <summary>
        /// An optional integer specifying the number of bytes to delete, start at the
        /// byte offset specified by the offset property, measured from the beginning of the file.
        /// </summary>
        [DataMember(Name="deletedLength", IsRequired = true)]
        public int DeletedLength { get; set; }

        /// <summary>
        /// An optional string that specifies the byte sequence to be inserted at the byte offset
        /// specified by the offset property, measured from the beginning of the file.
        /// </summary>
        [DataMember(Name="insertedBytes", IsRequired = true)]
        public int InsertedBytes { get; set; }

        private void Init(int offsetArg, int deletedLengthArg, int insertedBytesArg)
        {
            this.Offset = offsetArg;
            this.DeletedLength = deletedLengthArg;
            this.InsertedBytes = insertedBytesArg;
        }

        /// <summary>Initializes a new instance of the <see cref="Replacement" /> class.</summary>
        public Replacement()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="Replacement" /> class with the supplied data.</summary>
        /// <param name="offsetArg">An initialization value for the <see cref="P:Offset" /> member.</param>
        /// <param name="deletedLengthArg">An initialization value for the <see cref="P:DeletedLength" /> member.</param>
        /// <param name="insertedBytesArg">An initialization value for the <see cref="P:InsertedBytes" /> member.</param>
        public Replacement(int offsetArg, int deletedLengthArg, int insertedBytesArg)
        {
            this.Init(
                offsetArg, 
                deletedLengthArg, 
                insertedBytesArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="Replacement" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public Replacement(Replacement other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.Offset, 
                other.DeletedLength, 
                other.InsertedBytes
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public Replacement DeepClone()
        {
            return (Replacement)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new Replacement(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                result = (result * 31) + (int)this.Offset;
                result = (result * 31) + (int)this.DeletedLength;
                result = (result * 31) + (int)this.InsertedBytes;
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as Replacement);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(Replacement other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.Offset != other.Offset)
            {
                return false;
            }

            if (this.DeletedLength != other.DeletedLength)
            {
                return false;
            }

            if (this.InsertedBytes != other.InsertedBytes)
            {
                return false;
            }

            return true;
        }
    }

    /// <summary>
    /// Represents one or more observations about an analysis target produced by a static analysis tool.
    /// </summary>
    /// <remarks>
    /// A result frequently, but not always, represents a code defect.
    /// </remarks>
    [DataContract]
    [CompilerGenerated]
    public sealed class Result : ISyntax, IEquatable<Result>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public SarifGrammarKind SyntaxKind { get { return SarifGrammarKind.Result; } }

        /// <summary>
        /// An opaque, stable identifier that uniquely identifies the specific rule associated with
        /// the result (e.g., CA2001).
        /// </summary>
        [DataMember(Name="ruleId", IsRequired = true)]
        public string RuleId { get; set; }

        /// <summary>
        /// A string specifying the kind of observation this result represents.
        /// This shall be one of the following: warning, error, pass, pending, note, notApplicable, internalError.
        /// If this member is not present, its implied value is 'warning'.
        /// </summary>
        [DataMember(Name="kind", IsRequired = false, EmitDefaultValue = false)]
        public ResultKind Kind { get; set; }

        /// <summary>
        /// A string that comprehensively describes the result to the users.
        /// </summary>
        [DataMember(Name="fullMessage", IsRequired = true)]
        public string FullMessage { get; set; }

        /// <summary>
        /// A short description that summarizes an issue to the user in one or two lines.
        /// </summary>
        [DataMember(Name="shortMessage", IsRequired = false, EmitDefaultValue = false)]
        public string ShortMessage { get; set; }

        /// <summary>
        /// A formattedMessage object that can be used to construct a fully formatted message that describes the result.
        /// If the formatted message property is present on an result, the full message property shall not be present.
        /// If the full message property is present on an result, the formatted message property shall not be present
        /// </summary>
        [DataMember(Name="formattedMessage", IsRequired = false, EmitDefaultValue = false)]
        public FormattedMessage FormattedMessage { get; set; }

        /// <summary>
        /// Specifies one or more peer locations where an issue is located. Note that this is not used
        /// to point to multiple instances of the same issue; separate instances should have separate
        /// issue objects. For example, a misspelled partial class in C# may list all the source
        /// lines on which the partial class is declared as separate top-level locations. However, two
        /// independent misspellings of the same word need to be top level issues.
        /// </summary>
        [DataMember(Name="locations", IsRequired = true)]
        public IList<Location> Locations { get; set; }

        /// <summary>
        /// A string that baselining mechanisms can merge with other data to help uniquely identify this issue, run-over-run.
        /// </summary>
        [DataMember(Name="toolFingerprint", IsRequired = false, EmitDefaultValue = false)]
        public string ToolFingerprint { get; set; }

        /// <summary>
        /// A grouped set of locations, if available, that represent stacks associated with this result.
        /// </summary>
        [DataMember(Name="stacks", IsRequired = false, EmitDefaultValue = false)]
        public IList<AnnotatedCodeLocation> Stacks { get; set; }

        /// <summary>
        /// A grouped set of location, if available, that comprise annotated
        /// execution flows through code which are associated with this result.
        /// </summary>
        [DataMember(Name="executionFlows", IsRequired = false, EmitDefaultValue = false)]
        public IList<IList<AnnotatedCodeLocation>> ExecutionFlows { get; set; }

        /// <summary>
        /// A grouped set of locations and messages, if available, that represent code areas that are related
        /// to this result.
        /// </summary>
        [DataMember(Name="relatedLocations", IsRequired = false, EmitDefaultValue = false)]
        public IList<AnnotatedCodeLocation> RelatedLocations { get; set; }

        /// <summary>
        /// A flag that indicates whether or not this result was suppressed in source code.
        /// </summary>
        [DataMember(Name="isSuppressedInSource", IsRequired = false, EmitDefaultValue = false)]
        public bool IsSuppressedInSource { get; set; }

        /// <summary>
        /// An array of fix objects, if available, that can be applied in order to correct this result.
        /// </summary>
        [DataMember(Name="fixes", IsRequired = false, EmitDefaultValue = false)]
        public IList<Fix> Fixes { get; set; }

        /// <summary>
        /// Key/value pairs that provide additional details about the result.
        /// </summary>
        [DataMember(Name="properties", IsRequired = false, EmitDefaultValue = false)]
        public global::System.Collections.Generic.Dictionary<string, string> Properties { get; set; }

        private void Init(string ruleIdArg, ResultKind kindArg, string fullMessageArg, string shortMessageArg, FormattedMessage formattedMessageArg, IEnumerable<Location> locationsArg, string toolFingerprintArg, IEnumerable<AnnotatedCodeLocation> stacksArg, IEnumerable<IEnumerable<AnnotatedCodeLocation>> executionFlowsArg, IEnumerable<AnnotatedCodeLocation> relatedLocationsArg, bool isSuppressedInSourceArg, IEnumerable<Fix> fixesArg, global::System.Collections.Generic.Dictionary<string, string> propertiesArg)
        {
            if (ruleIdArg != null)
            {
                this.RuleId = ruleIdArg;
            }
            this.Kind = kindArg;
            if (fullMessageArg != null)
            {
                this.FullMessage = fullMessageArg;
            }
            if (shortMessageArg != null)
            {
                this.ShortMessage = shortMessageArg;
            }
            if (formattedMessageArg != null)
            {
                this.FormattedMessage = new FormattedMessage(formattedMessageArg);
            }
            if (locationsArg != null)
            {
                var destination_0 = new List<Location>();
                if (locationsArg != null)
                {
                    foreach (var value_0 in locationsArg)
                    {
                        if (value_0 == null)
                        {
                            destination_0.Add(null);
                        }
                        else
                        {
                            destination_0.Add(new Location(value_0));
                        }
                    }
                }

                this.Locations = destination_0;
            }
            if (toolFingerprintArg != null)
            {
                this.ToolFingerprint = toolFingerprintArg;
            }
            if (stacksArg != null)
            {
                var destination_1 = new List<AnnotatedCodeLocation>();
                if (stacksArg != null)
                {
                    foreach (var value_1 in stacksArg)
                    {
                        if (value_1 == null)
                        {
                            destination_1.Add(null);
                        }
                        else
                        {
                            destination_1.Add(new AnnotatedCodeLocation(value_1));
                        }
                    }
                }

                this.Stacks = destination_1;
            }
            if (executionFlowsArg != null)
            {
                var destination_2 = new List<IList<AnnotatedCodeLocation>>();
                if (executionFlowsArg != null)
                {
                    foreach (var value_2 in executionFlowsArg)
                    {
                        var destination_3 = new List<AnnotatedCodeLocation>();
                        if (value_2 != null)
                        {
                            foreach (var value_3 in value_2)
                            {
                                if (value_3 == null)
                                {
                                    destination_3.Add(null);
                                }
                                else
                                {
                                    destination_3.Add(new AnnotatedCodeLocation(value_3));
                                }
                            }
                        }

                        destination_2.Add(destination_3);
                    }
                }

                this.ExecutionFlows = destination_2;
            }
            if (relatedLocationsArg != null)
            {
                var destination_4 = new List<AnnotatedCodeLocation>();
                if (relatedLocationsArg != null)
                {
                    foreach (var value_4 in relatedLocationsArg)
                    {
                        if (value_4 == null)
                        {
                            destination_4.Add(null);
                        }
                        else
                        {
                            destination_4.Add(new AnnotatedCodeLocation(value_4));
                        }
                    }
                }

                this.RelatedLocations = destination_4;
            }
            this.IsSuppressedInSource = isSuppressedInSourceArg;
            if (fixesArg != null)
            {
                var destination_5 = new List<Fix>();
                if (fixesArg != null)
                {
                    foreach (var value_5 in fixesArg)
                    {
                        if (value_5 == null)
                        {
                            destination_5.Add(null);
                        }
                        else
                        {
                            destination_5.Add(new Fix(value_5));
                        }
                    }
                }

                this.Fixes = destination_5;
            }
            if (propertiesArg != null)
            {
                this.Properties = new global::System.Collections.Generic.Dictionary<string, string>(propertiesArg);
            }
        }

        /// <summary>Initializes a new instance of the <see cref="Result" /> class.</summary>
        public Result()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="Result" /> class with the supplied data.</summary>
        /// <param name="ruleIdArg">An initialization value for the <see cref="P:RuleId" /> member.</param>
        /// <param name="kindArg">An initialization value for the <see cref="P:Kind" /> member.</param>
        /// <param name="fullMessageArg">An initialization value for the <see cref="P:FullMessage" /> member.</param>
        /// <param name="shortMessageArg">An initialization value for the <see cref="P:ShortMessage" /> member.</param>
        /// <param name="formattedMessageArg">An initialization value for the <see cref="P:FormattedMessage" /> member.</param>
        /// <param name="locationsArg">An initialization value for the <see cref="P:Locations" /> member.</param>
        /// <param name="toolFingerprintArg">An initialization value for the <see cref="P:ToolFingerprint" /> member.</param>
        /// <param name="stacksArg">An initialization value for the <see cref="P:Stacks" /> member.</param>
        /// <param name="executionFlowsArg">An initialization value for the <see cref="P:ExecutionFlows" /> member.</param>
        /// <param name="relatedLocationsArg">An initialization value for the <see cref="P:RelatedLocations" /> member.</param>
        /// <param name="isSuppressedInSourceArg">An initialization value for the <see cref="P:IsSuppressedInSource" /> member.</param>
        /// <param name="fixesArg">An initialization value for the <see cref="P:Fixes" /> member.</param>
        /// <param name="propertiesArg">An initialization value for the <see cref="P:Properties" /> member.</param>
        public Result(string ruleIdArg, ResultKind kindArg, string fullMessageArg, string shortMessageArg, FormattedMessage formattedMessageArg, IEnumerable<Location> locationsArg, string toolFingerprintArg, IEnumerable<AnnotatedCodeLocation> stacksArg, IEnumerable<IEnumerable<AnnotatedCodeLocation>> executionFlowsArg, IEnumerable<AnnotatedCodeLocation> relatedLocationsArg, bool isSuppressedInSourceArg, IEnumerable<Fix> fixesArg, global::System.Collections.Generic.Dictionary<string, string> propertiesArg)
        {
            this.Init(
                ruleIdArg, 
                kindArg, 
                fullMessageArg, 
                shortMessageArg, 
                formattedMessageArg, 
                locationsArg, 
                toolFingerprintArg, 
                stacksArg, 
                executionFlowsArg, 
                relatedLocationsArg, 
                isSuppressedInSourceArg, 
                fixesArg, 
                propertiesArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="Result" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public Result(Result other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.RuleId, 
                other.Kind, 
                other.FullMessage, 
                other.ShortMessage, 
                other.FormattedMessage, 
                other.Locations, 
                other.ToolFingerprint, 
                other.Stacks, 
                other.ExecutionFlows, 
                other.RelatedLocations, 
                other.IsSuppressedInSource, 
                other.Fixes, 
                other.Properties
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public Result DeepClone()
        {
            return (Result)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new Result(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                if (this.RuleId != null)
                {
                    result = (result * 31) + this.RuleId.GetHashCode();
                }
                result = (result * 31) + (int)this.Kind;
                if (this.FullMessage != null)
                {
                    result = (result * 31) + this.FullMessage.GetHashCode();
                }
                if (this.ShortMessage != null)
                {
                    result = (result * 31) + this.ShortMessage.GetHashCode();
                }
                if (this.FormattedMessage != null)
                {
                    result = (result * 31) + this.FormattedMessage.GetHashCode();
                }
                foreach (var value_0 in this.Locations)
                {
                    result = result * 31;
                    if (value_0 != null)
                    {
                        result = (result * 31) + value_0.GetHashCode();
                    }
                }

                if (this.ToolFingerprint != null)
                {
                    result = (result * 31) + this.ToolFingerprint.GetHashCode();
                }
                foreach (var value_1 in this.Stacks)
                {
                    result = result * 31;
                    if (value_1 != null)
                    {
                        result = (result * 31) + value_1.GetHashCode();
                    }
                }

                foreach (var value_2 in this.ExecutionFlows)
                {
                    result = result * 31;
                    if (value_2 != null)
                    {
                        foreach (var value_3 in value_2)
                        {
                            result = result * 31;
                            if (value_3 != null)
                            {
                                result = (result * 31) + value_3.GetHashCode();
                            }
                        }
                    }
                }

                foreach (var value_4 in this.RelatedLocations)
                {
                    result = result * 31;
                    if (value_4 != null)
                    {
                        result = (result * 31) + value_4.GetHashCode();
                    }
                }

                if (this.IsSuppressedInSource)
                {
                    result = (result * 31) + 1;
                }
                foreach (var value_5 in this.Fixes)
                {
                    result = result * 31;
                    if (value_5 != null)
                    {
                        result = (result * 31) + value_5.GetHashCode();
                    }
                }

                if (this.Properties != null)
                {
                    // Use xor for dictionaries to be order-independent
                    int xor_0 = 0;
                    foreach (var value_6 in this.Properties)
                    {
                        xor_0 ^= (value_6.Key ?? String.Empty).GetHashCode();
                        xor_0 ^= (value_6.Value ?? String.Empty).GetHashCode();
                    }

                    result = (result * 31) + xor_0;
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as Result);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(Result other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.RuleId != other.RuleId)
            {
                return false;
            }

            if (this.Kind != other.Kind)
            {
                return false;
            }

            if (this.FullMessage != other.FullMessage)
            {
                return false;
            }

            if (this.ShortMessage != other.ShortMessage)
            {
                return false;
            }

            if (!global::System.Object.Equals(this.FormattedMessage, other.FormattedMessage))
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.Locations, other.Locations))
            {
                if (this.Locations == null || other.Locations == null)
                {
                    return false;
                }

                if (this.Locations.Count != other.Locations.Count)
                {
                    return false;
                }

                int max_0 = this.Locations.Count;
                for (int index_0 = 0; index_0 < max_0; ++index_0)
                {
                    var value_7 = this.Locations[index_0];
                    var value_8 = other.Locations[index_0];
                    if (!global::System.Object.Equals(value_7, value_8))
                    {
                        return false;
                    }
                }
            }

            if (this.ToolFingerprint != other.ToolFingerprint)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.Stacks, other.Stacks))
            {
                if (this.Stacks == null || other.Stacks == null)
                {
                    return false;
                }

                if (this.Stacks.Count != other.Stacks.Count)
                {
                    return false;
                }

                int max_1 = this.Stacks.Count;
                for (int index_1 = 0; index_1 < max_1; ++index_1)
                {
                    var value_9 = this.Stacks[index_1];
                    var value_10 = other.Stacks[index_1];
                    if (!global::System.Object.Equals(value_9, value_10))
                    {
                        return false;
                    }
                }
            }

            if (!global::System.Object.ReferenceEquals(this.ExecutionFlows, other.ExecutionFlows))
            {
                if (this.ExecutionFlows == null || other.ExecutionFlows == null)
                {
                    return false;
                }

                if (this.ExecutionFlows.Count != other.ExecutionFlows.Count)
                {
                    return false;
                }

                int max_2 = this.ExecutionFlows.Count;
                for (int index_2 = 0; index_2 < max_2; ++index_2)
                {
                    var value_11 = this.ExecutionFlows[index_2];
                    var value_12 = other.ExecutionFlows[index_2];
                    if (!global::System.Object.ReferenceEquals(value_11, value_12))
                    {
                        if (value_11 == null || value_12 == null)
                        {
                            return false;
                        }

                        if (value_11.Count != value_12.Count)
                        {
                            return false;
                        }

                        int max_3 = value_11.Count;
                        for (int index_3 = 0; index_3 < max_3; ++index_3)
                        {
                            var value_13 = value_11[index_3];
                            var value_14 = value_12[index_3];
                            if (!global::System.Object.Equals(value_13, value_14))
                            {
                                return false;
                            }
                        }
                    }
                }
            }

            if (!global::System.Object.ReferenceEquals(this.RelatedLocations, other.RelatedLocations))
            {
                if (this.RelatedLocations == null || other.RelatedLocations == null)
                {
                    return false;
                }

                if (this.RelatedLocations.Count != other.RelatedLocations.Count)
                {
                    return false;
                }

                int max_4 = this.RelatedLocations.Count;
                for (int index_4 = 0; index_4 < max_4; ++index_4)
                {
                    var value_15 = this.RelatedLocations[index_4];
                    var value_16 = other.RelatedLocations[index_4];
                    if (!global::System.Object.Equals(value_15, value_16))
                    {
                        return false;
                    }
                }
            }

            if (this.IsSuppressedInSource != other.IsSuppressedInSource)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.Fixes, other.Fixes))
            {
                if (this.Fixes == null || other.Fixes == null)
                {
                    return false;
                }

                if (this.Fixes.Count != other.Fixes.Count)
                {
                    return false;
                }

                int max_5 = this.Fixes.Count;
                for (int index_5 = 0; index_5 < max_5; ++index_5)
                {
                    var value_17 = this.Fixes[index_5];
                    var value_18 = other.Fixes[index_5];
                    if (!global::System.Object.Equals(value_17, value_18))
                    {
                        return false;
                    }
                }
            }

            if (!global::System.Object.ReferenceEquals(this.Properties, other.Properties))
            {
                if (this.Properties == null || other.Properties == null || this.Properties.Count != other.Properties.Count)
                {
                    return false;
                }
                foreach (var value_19 in this.Properties)
                {
                    string value_20;
                    if (!other.Properties.TryGetValue(value_19.Key, out value_20) || !global::System.Object.Equals(value_19.Value, value_20))
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }

    [DataContract]
    [CompilerGenerated]
    public enum ResultKind
    {
        Unknown = 0,
        Error,
        Warning,
        Pass,
        Note,
        NotApplicable,
        InternalError,
        ConfigurationError,
    }

    /// <summary>
    /// Static Analysis Results Format (SARIF) Version 1.0 JSON Schema (Draft 0.4). SARIF defines a standard format for the output of static analysis tools.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class ResultLog : ISyntax, IEquatable<ResultLog>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public SarifGrammarKind SyntaxKind { get { return SarifGrammarKind.ResultLog; } }

        /// <summary>
        /// The SARIF tool format version of this log file. This value should be set to 0.4, currently.
        /// This is the third proposed revision of a file format that is not yet completely finalized.
        /// </summary>
        [DataMember(Name="version", IsRequired = true)]
        public SarifVersion Version { get; set; }

        /// <summary>
        /// The set of runLogs contained in this SARIF log.
        /// </summary>
        [DataMember(Name="runLogs", IsRequired = true)]
        public IList<RunLog> RunLogs { get; set; }

        private void Init(SarifVersion versionArg, IEnumerable<RunLog> runLogsArg)
        {
            this.Version = versionArg;
            if (runLogsArg != null)
            {
                var destination_0 = new List<RunLog>();
                if (runLogsArg != null)
                {
                    foreach (var value_0 in runLogsArg)
                    {
                        if (value_0 == null)
                        {
                            destination_0.Add(null);
                        }
                        else
                        {
                            destination_0.Add(new RunLog(value_0));
                        }
                    }
                }

                this.RunLogs = destination_0;
            }
        }

        /// <summary>Initializes a new instance of the <see cref="ResultLog" /> class.</summary>
        public ResultLog()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="ResultLog" /> class with the supplied data.</summary>
        /// <param name="versionArg">An initialization value for the <see cref="P:Version" /> member.</param>
        /// <param name="runLogsArg">An initialization value for the <see cref="P:RunLogs" /> member.</param>
        public ResultLog(SarifVersion versionArg, IEnumerable<RunLog> runLogsArg)
        {
            this.Init(
                versionArg, 
                runLogsArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="ResultLog" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public ResultLog(ResultLog other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.Version, 
                other.RunLogs
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public ResultLog DeepClone()
        {
            return (ResultLog)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new ResultLog(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                result = (result * 31) + (int)this.Version;
                foreach (var value_0 in this.RunLogs)
                {
                    result = result * 31;
                    if (value_0 != null)
                    {
                        result = (result * 31) + value_0.GetHashCode();
                    }
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as ResultLog);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(ResultLog other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.Version != other.Version)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.RunLogs, other.RunLogs))
            {
                if (this.RunLogs == null || other.RunLogs == null)
                {
                    return false;
                }

                if (this.RunLogs.Count != other.RunLogs.Count)
                {
                    return false;
                }

                int max_0 = this.RunLogs.Count;
                for (int index_0 = 0; index_0 < max_0; ++index_0)
                {
                    var value_1 = this.RunLogs[index_0];
                    var value_2 = other.RunLogs[index_0];
                    if (!global::System.Object.Equals(value_1, value_2))
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }

    /// <summary>
    /// An object that contains information about an analysis rule.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class RuleDescriptor : ISyntax, IEquatable<RuleDescriptor>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public SarifGrammarKind SyntaxKind { get { return SarifGrammarKind.RuleDescriptor; } }

        /// <summary>
        /// A string that contains a stable, opaque identifier for a rule.
        /// </summary>
        [DataMember(Name="id", IsRequired = true)]
        public string Id { get; set; }

        /// <summary>
        /// An optional string that contains a rule identifier that is understandable to an end user.
        /// </summary>
        [DataMember(Name="name", IsRequired = false, EmitDefaultValue = false)]
        public string Name { get; set; }

        /// <summary>
        /// A string that contains a concise description of the rule. The short description property
        /// should be a single sentence that is understandable when displayed in user interface contexts
        /// where the available space is limited to a single line of text.
        /// </summary>
        [DataMember(Name="shortDescription", IsRequired = false, EmitDefaultValue = false)]
        public string ShortDescription { get; set; }

        /// <summary>
        /// A string whose value is a string that describes the rule. The fullDescription property should,
        /// as far as possible, provide details sufficient to enable resolution of any problem indicated
        /// by the result.
        /// </summary>
        [DataMember(Name="fullDescription", IsRequired = false, EmitDefaultValue = false)]
        public string FullDescription { get; set; }

        /// <summary>
        /// A dictionary consisting of a set of name/value pairs with arbitrary names. The options
        /// objects shall describe the set of configurable options supported by the rule. The value
        /// within each name/value pair shall be a string, which may be the empty string. The value
        /// shall not be a dictionary or sub-object.
        /// </summary>
        [DataMember(Name="options", IsRequired = false, EmitDefaultValue = false)]
        public global::System.Collections.Generic.Dictionary<string, string> Options { get; set; }

        /// <summary>
        /// A dictionary consisting of a set of name/value pairs with arbitrary names. The value
        /// within each name/value pair shall be a string that can be passed to a string formatting
        /// function (e.g., the C language printf function) to construct a formatted message in
        /// combination with an arbitrary number of additional function arguments.
        /// </summary>
        [DataMember(Name="formatSpecifiers", IsRequired = false, EmitDefaultValue = false)]
        public global::System.Collections.Generic.Dictionary<string, string> FormatSpecifiers { get; set; }

        /// <summary>
        /// A dictionary consisting of a set of name/value pairs with arbitrary names. This
        /// allows tools to include information about the rule that is not explicitly specified
        /// in the SARIF format. The value within each name/value pair shall be a string,
        /// which may be the empty string. The value shall not be a dictionary or sub-object.
        /// </summary>
        [DataMember(Name="properties", IsRequired = false, EmitDefaultValue = false)]
        public global::System.Collections.Generic.Dictionary<string, string> Properties { get; set; }

        private void Init(string idArg, string nameArg, string shortDescriptionArg, string fullDescriptionArg, global::System.Collections.Generic.Dictionary<string, string> optionsArg, global::System.Collections.Generic.Dictionary<string, string> formatSpecifiersArg, global::System.Collections.Generic.Dictionary<string, string> propertiesArg)
        {
            if (idArg != null)
            {
                this.Id = idArg;
            }
            if (nameArg != null)
            {
                this.Name = nameArg;
            }
            if (shortDescriptionArg != null)
            {
                this.ShortDescription = shortDescriptionArg;
            }
            if (fullDescriptionArg != null)
            {
                this.FullDescription = fullDescriptionArg;
            }
            if (optionsArg != null)
            {
                this.Options = new global::System.Collections.Generic.Dictionary<string, string>(optionsArg);
            }
            if (formatSpecifiersArg != null)
            {
                this.FormatSpecifiers = new global::System.Collections.Generic.Dictionary<string, string>(formatSpecifiersArg);
            }
            if (propertiesArg != null)
            {
                this.Properties = new global::System.Collections.Generic.Dictionary<string, string>(propertiesArg);
            }
        }

        /// <summary>Initializes a new instance of the <see cref="RuleDescriptor" /> class.</summary>
        public RuleDescriptor()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="RuleDescriptor" /> class with the supplied data.</summary>
        /// <param name="idArg">An initialization value for the <see cref="P:Id" /> member.</param>
        /// <param name="nameArg">An initialization value for the <see cref="P:Name" /> member.</param>
        /// <param name="shortDescriptionArg">An initialization value for the <see cref="P:ShortDescription" /> member.</param>
        /// <param name="fullDescriptionArg">An initialization value for the <see cref="P:FullDescription" /> member.</param>
        /// <param name="optionsArg">An initialization value for the <see cref="P:Options" /> member.</param>
        /// <param name="formatSpecifiersArg">An initialization value for the <see cref="P:FormatSpecifiers" /> member.</param>
        /// <param name="propertiesArg">An initialization value for the <see cref="P:Properties" /> member.</param>
        public RuleDescriptor(string idArg, string nameArg, string shortDescriptionArg, string fullDescriptionArg, global::System.Collections.Generic.Dictionary<string, string> optionsArg, global::System.Collections.Generic.Dictionary<string, string> formatSpecifiersArg, global::System.Collections.Generic.Dictionary<string, string> propertiesArg)
        {
            this.Init(
                idArg, 
                nameArg, 
                shortDescriptionArg, 
                fullDescriptionArg, 
                optionsArg, 
                formatSpecifiersArg, 
                propertiesArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="RuleDescriptor" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public RuleDescriptor(RuleDescriptor other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.Id, 
                other.Name, 
                other.ShortDescription, 
                other.FullDescription, 
                other.Options, 
                other.FormatSpecifiers, 
                other.Properties
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public RuleDescriptor DeepClone()
        {
            return (RuleDescriptor)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new RuleDescriptor(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                if (this.Id != null)
                {
                    result = (result * 31) + this.Id.GetHashCode();
                }
                if (this.Name != null)
                {
                    result = (result * 31) + this.Name.GetHashCode();
                }
                if (this.ShortDescription != null)
                {
                    result = (result * 31) + this.ShortDescription.GetHashCode();
                }
                if (this.FullDescription != null)
                {
                    result = (result * 31) + this.FullDescription.GetHashCode();
                }
                if (this.Options != null)
                {
                    // Use xor for dictionaries to be order-independent
                    int xor_0 = 0;
                    foreach (var value_0 in this.Options)
                    {
                        xor_0 ^= (value_0.Key ?? String.Empty).GetHashCode();
                        xor_0 ^= (value_0.Value ?? String.Empty).GetHashCode();
                    }

                    result = (result * 31) + xor_0;
                }
                if (this.FormatSpecifiers != null)
                {
                    // Use xor for dictionaries to be order-independent
                    int xor_1 = 0;
                    foreach (var value_1 in this.FormatSpecifiers)
                    {
                        xor_1 ^= (value_1.Key ?? String.Empty).GetHashCode();
                        xor_1 ^= (value_1.Value ?? String.Empty).GetHashCode();
                    }

                    result = (result * 31) + xor_1;
                }
                if (this.Properties != null)
                {
                    // Use xor for dictionaries to be order-independent
                    int xor_2 = 0;
                    foreach (var value_2 in this.Properties)
                    {
                        xor_2 ^= (value_2.Key ?? String.Empty).GetHashCode();
                        xor_2 ^= (value_2.Value ?? String.Empty).GetHashCode();
                    }

                    result = (result * 31) + xor_2;
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as RuleDescriptor);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(RuleDescriptor other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.Id != other.Id)
            {
                return false;
            }

            if (this.Name != other.Name)
            {
                return false;
            }

            if (this.ShortDescription != other.ShortDescription)
            {
                return false;
            }

            if (this.FullDescription != other.FullDescription)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.Options, other.Options))
            {
                if (this.Options == null || other.Options == null || this.Options.Count != other.Options.Count)
                {
                    return false;
                }
                foreach (var value_3 in this.Options)
                {
                    string value_4;
                    if (!other.Options.TryGetValue(value_3.Key, out value_4) || !global::System.Object.Equals(value_3.Value, value_4))
                    {
                        return false;
                    }
                }
            }

            if (!global::System.Object.ReferenceEquals(this.FormatSpecifiers, other.FormatSpecifiers))
            {
                if (this.FormatSpecifiers == null || other.FormatSpecifiers == null || this.FormatSpecifiers.Count != other.FormatSpecifiers.Count)
                {
                    return false;
                }
                foreach (var value_5 in this.FormatSpecifiers)
                {
                    string value_6;
                    if (!other.FormatSpecifiers.TryGetValue(value_5.Key, out value_6) || !global::System.Object.Equals(value_5.Value, value_6))
                    {
                        return false;
                    }
                }
            }

            if (!global::System.Object.ReferenceEquals(this.Properties, other.Properties))
            {
                if (this.Properties == null || other.Properties == null || this.Properties.Count != other.Properties.Count)
                {
                    return false;
                }
                foreach (var value_7 in this.Properties)
                {
                    string value_8;
                    if (!other.Properties.TryGetValue(value_7.Key, out value_8) || !global::System.Object.Equals(value_7.Value, value_8))
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }

    /// <summary>
    /// A runInfo object describes the invocation of the static analysis tool that produced the results
    /// specified in the containing runLog object.
    /// NOTE: The information in the runInfo object makes it possible to precisely repeat a run of a
    /// static analysis tool, and to verify that the results reported in the log file were generated
    /// by an appropriate invocation of the tool.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class RunInfo : ISyntax, IEquatable<RunInfo>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public SarifGrammarKind SyntaxKind { get { return SarifGrammarKind.RunInfo; } }

        /// <summary>
        /// A string that describes any parameterization for the tool invocation. For command line tools
        /// this string may consist of the completely specified command line used to invoke the tool.
        /// </summary>
        [DataMember(Name="invocationInfo", IsRequired = false, EmitDefaultValue = false)]
        public string InvocationInfo { get; set; }

        /// <summary>
        /// An array, each of whose elements is a fileReference object representing the location of
        /// a single analysis target scanned during the run. When present, this array shall contain one entry
        /// fo reach analysis target that was scanned, even if the analysis targets were not individually specified
        /// on the command line.
        /// NOTE 1: The command line with which the tool was invoked might specify its input files by means
        /// of a wild card such as *.cc, or it might specify them implicitly, for example, by scanning the
        /// files in the current directory.
        /// The analysisTargets array shall be empty if no analysis targets were scanned in the course of the run.
        /// NOTE 2: This could happen if the command line specified a wildcard such as *.cc for the input files,
        /// and no files matched the wildcard.
        /// </summary>
        [DataMember(Name="analysisTargets", IsRequired = false, EmitDefaultValue = false)]
        public IList<FileReference> AnalysisTargets { get; set; }

        private void Init(string invocationInfoArg, IEnumerable<FileReference> analysisTargetsArg)
        {
            if (invocationInfoArg != null)
            {
                this.InvocationInfo = invocationInfoArg;
            }
            if (analysisTargetsArg != null)
            {
                var destination_0 = new List<FileReference>();
                if (analysisTargetsArg != null)
                {
                    foreach (var value_0 in analysisTargetsArg)
                    {
                        if (value_0 == null)
                        {
                            destination_0.Add(null);
                        }
                        else
                        {
                            destination_0.Add(new FileReference(value_0));
                        }
                    }
                }

                this.AnalysisTargets = destination_0;
            }
        }

        /// <summary>Initializes a new instance of the <see cref="RunInfo" /> class.</summary>
        public RunInfo()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="RunInfo" /> class with the supplied data.</summary>
        /// <param name="invocationInfoArg">An initialization value for the <see cref="P:InvocationInfo" /> member.</param>
        /// <param name="analysisTargetsArg">An initialization value for the <see cref="P:AnalysisTargets" /> member.</param>
        public RunInfo(string invocationInfoArg, IEnumerable<FileReference> analysisTargetsArg)
        {
            this.Init(
                invocationInfoArg, 
                analysisTargetsArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="RunInfo" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public RunInfo(RunInfo other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.InvocationInfo, 
                other.AnalysisTargets
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public RunInfo DeepClone()
        {
            return (RunInfo)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new RunInfo(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                if (this.InvocationInfo != null)
                {
                    result = (result * 31) + this.InvocationInfo.GetHashCode();
                }
                foreach (var value_0 in this.AnalysisTargets)
                {
                    result = result * 31;
                    if (value_0 != null)
                    {
                        result = (result * 31) + value_0.GetHashCode();
                    }
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as RunInfo);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(RunInfo other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.InvocationInfo != other.InvocationInfo)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.AnalysisTargets, other.AnalysisTargets))
            {
                if (this.AnalysisTargets == null || other.AnalysisTargets == null)
                {
                    return false;
                }

                if (this.AnalysisTargets.Count != other.AnalysisTargets.Count)
                {
                    return false;
                }

                int max_0 = this.AnalysisTargets.Count;
                for (int index_0 = 0; index_0 < max_0; ++index_0)
                {
                    var value_1 = this.AnalysisTargets[index_0];
                    var value_2 = other.AnalysisTargets[index_0];
                    if (!global::System.Object.Equals(value_1, value_2))
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }

    [DataContract]
    [CompilerGenerated]
    public sealed class RunLog : ISyntax, IEquatable<RunLog>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public SarifGrammarKind SyntaxKind { get { return SarifGrammarKind.RunLog; } }

        /// <summary>
        /// Information about the tool or tool pipeline that generated the results in this log. A results
        /// log can only contain results produced by a single tool or tool pipeline. A results log can
        /// aggregate results from multiple tool log files, as long as context around the tool run
        /// (tool command-line arguments and the like) is identical for all aggregated files.
        /// </summary>
        [DataMember(Name="toolInfo", IsRequired = true)]
        public ToolInfo ToolInfo { get; set; }

        /// <summary>
        /// A runInfo object describes the invocation of the static analysis tool that produced the results
        /// specified in the containing runLog object.
        /// </summary>
        [DataMember(Name="runInfo", IsRequired = false, EmitDefaultValue = false)]
        public RunInfo RunInfo { get; set; }

        /// <summary>
        /// The set of results contained in an SARIF log.
        /// </summary>
        [DataMember(Name="results", IsRequired = true)]
        public IList<Result> Results { get; set; }

        private void Init(ToolInfo toolInfoArg, RunInfo runInfoArg, IEnumerable<Result> resultsArg)
        {
            if (toolInfoArg != null)
            {
                this.ToolInfo = new ToolInfo(toolInfoArg);
            }
            if (runInfoArg != null)
            {
                this.RunInfo = new RunInfo(runInfoArg);
            }
            if (resultsArg != null)
            {
                var destination_0 = new List<Result>();
                if (resultsArg != null)
                {
                    foreach (var value_0 in resultsArg)
                    {
                        if (value_0 == null)
                        {
                            destination_0.Add(null);
                        }
                        else
                        {
                            destination_0.Add(new Result(value_0));
                        }
                    }
                }

                this.Results = destination_0;
            }
        }

        /// <summary>Initializes a new instance of the <see cref="RunLog" /> class.</summary>
        public RunLog()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="RunLog" /> class with the supplied data.</summary>
        /// <param name="toolInfoArg">An initialization value for the <see cref="P:ToolInfo" /> member.</param>
        /// <param name="runInfoArg">An initialization value for the <see cref="P:RunInfo" /> member.</param>
        /// <param name="resultsArg">An initialization value for the <see cref="P:Results" /> member.</param>
        public RunLog(ToolInfo toolInfoArg, RunInfo runInfoArg, IEnumerable<Result> resultsArg)
        {
            this.Init(
                toolInfoArg, 
                runInfoArg, 
                resultsArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="RunLog" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public RunLog(RunLog other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.ToolInfo, 
                other.RunInfo, 
                other.Results
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public RunLog DeepClone()
        {
            return (RunLog)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new RunLog(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                if (this.ToolInfo != null)
                {
                    result = (result * 31) + this.ToolInfo.GetHashCode();
                }
                if (this.RunInfo != null)
                {
                    result = (result * 31) + this.RunInfo.GetHashCode();
                }
                foreach (var value_0 in this.Results)
                {
                    result = result * 31;
                    if (value_0 != null)
                    {
                        result = (result * 31) + value_0.GetHashCode();
                    }
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as RunLog);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(RunLog other)
        {
            if (other == null)
            {
                return false;
            }

            if (!global::System.Object.Equals(this.ToolInfo, other.ToolInfo))
            {
                return false;
            }

            if (!global::System.Object.Equals(this.RunInfo, other.RunInfo))
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.Results, other.Results))
            {
                if (this.Results == null || other.Results == null)
                {
                    return false;
                }

                if (this.Results.Count != other.Results.Count)
                {
                    return false;
                }

                int max_0 = this.Results.Count;
                for (int index_0 = 0; index_0 < max_0; ++index_0)
                {
                    var value_1 = this.Results[index_0];
                    var value_2 = other.Results[index_0];
                    if (!global::System.Object.Equals(value_1, value_2))
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }

    [DataContract]
    [CompilerGenerated]
    public enum SarifVersion
    {
        Unknown = 0,
        ZeroDotFour,
    }

    /// <summary>
    /// Information about the tool or tool pipeline that generated the results in this log.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class ToolInfo : ISyntax, IEquatable<ToolInfo>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public SarifGrammarKind SyntaxKind { get { return SarifGrammarKind.ToolInfo; } }

        /// <summary>
        /// The name of the tool or tool pipeline that generated the results in this log, e.g., FxCop.
        /// </summary>
        [DataMember(Name="name", IsRequired = true)]
        public string Name { get; set; }

        /// <summary>
        /// The name of the tool along with its version and any other useful identifying information,
        /// such as its locale, e.g., 'CodeScanner 2.0, Developer Preview (en-US)'.
        /// </summary>
        [DataMember(Name="fullName", IsRequired = false, EmitDefaultValue = false)]
        public string FullName { get; set; }

        /// <summary>
        /// A version that refers to the tool as a whole (as opposed to, for example,
        /// the build version of an individual binary in the tool).
        /// </summary>
        [DataMember(Name="version", IsRequired = false, EmitDefaultValue = false)]
        public string Version { get; set; }

        /// <summary>
        /// For operating systems (such as Windows) that provide the data, the binary version
        /// of the primary tool exe.
        /// </summary>
        [DataMember(Name="fileVersion", IsRequired = false, EmitDefaultValue = false)]
        public string FileVersion { get; set; }

        /// <summary>
        /// An array of rule descriptor objects that describe all rules associated with an
        /// analysis tool or a specific run of an analysis tool.
        /// </summary>
        [DataMember(Name="ruleInfo", IsRequired = false, EmitDefaultValue = false)]
        public IList<RuleDescriptor> RuleInfo { get; set; }

        private void Init(string nameArg, string fullNameArg, string versionArg, string fileVersionArg, IEnumerable<RuleDescriptor> ruleInfoArg)
        {
            if (nameArg != null)
            {
                this.Name = nameArg;
            }
            if (fullNameArg != null)
            {
                this.FullName = fullNameArg;
            }
            if (versionArg != null)
            {
                this.Version = versionArg;
            }
            if (fileVersionArg != null)
            {
                this.FileVersion = fileVersionArg;
            }
            if (ruleInfoArg != null)
            {
                var destination_0 = new List<RuleDescriptor>();
                if (ruleInfoArg != null)
                {
                    foreach (var value_0 in ruleInfoArg)
                    {
                        if (value_0 == null)
                        {
                            destination_0.Add(null);
                        }
                        else
                        {
                            destination_0.Add(new RuleDescriptor(value_0));
                        }
                    }
                }

                this.RuleInfo = destination_0;
            }
        }

        /// <summary>Initializes a new instance of the <see cref="ToolInfo" /> class.</summary>
        public ToolInfo()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="ToolInfo" /> class with the supplied data.</summary>
        /// <param name="nameArg">An initialization value for the <see cref="P:Name" /> member.</param>
        /// <param name="fullNameArg">An initialization value for the <see cref="P:FullName" /> member.</param>
        /// <param name="versionArg">An initialization value for the <see cref="P:Version" /> member.</param>
        /// <param name="fileVersionArg">An initialization value for the <see cref="P:FileVersion" /> member.</param>
        /// <param name="ruleInfoArg">An initialization value for the <see cref="P:RuleInfo" /> member.</param>
        public ToolInfo(string nameArg, string fullNameArg, string versionArg, string fileVersionArg, IEnumerable<RuleDescriptor> ruleInfoArg)
        {
            this.Init(
                nameArg, 
                fullNameArg, 
                versionArg, 
                fileVersionArg, 
                ruleInfoArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="ToolInfo" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public ToolInfo(ToolInfo other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.Name, 
                other.FullName, 
                other.Version, 
                other.FileVersion, 
                other.RuleInfo
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public ToolInfo DeepClone()
        {
            return (ToolInfo)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new ToolInfo(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                if (this.Name != null)
                {
                    result = (result * 31) + this.Name.GetHashCode();
                }
                if (this.FullName != null)
                {
                    result = (result * 31) + this.FullName.GetHashCode();
                }
                if (this.Version != null)
                {
                    result = (result * 31) + this.Version.GetHashCode();
                }
                if (this.FileVersion != null)
                {
                    result = (result * 31) + this.FileVersion.GetHashCode();
                }
                foreach (var value_0 in this.RuleInfo)
                {
                    result = result * 31;
                    if (value_0 != null)
                    {
                        result = (result * 31) + value_0.GetHashCode();
                    }
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as ToolInfo);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(ToolInfo other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.Name != other.Name)
            {
                return false;
            }

            if (this.FullName != other.FullName)
            {
                return false;
            }

            if (this.Version != other.Version)
            {
                return false;
            }

            if (this.FileVersion != other.FileVersion)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.RuleInfo, other.RuleInfo))
            {
                if (this.RuleInfo == null || other.RuleInfo == null)
                {
                    return false;
                }

                if (this.RuleInfo.Count != other.RuleInfo.Count)
                {
                    return false;
                }

                int max_0 = this.RuleInfo.Count;
                for (int index_0 = 0; index_0 < max_0; ++index_0)
                {
                    var value_1 = this.RuleInfo[index_0];
                    var value_2 = other.RuleInfo[index_0];
                    if (!global::System.Object.Equals(value_1, value_2))
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }

    /// <summary>Visitor for a SarifGrammar tree.</summary>
    public abstract class SarifGrammarVisitor<T>
    {
        /// <summary>Starts a visit of a SarifGrammar tree.</summary>
        /// <param name="node">The node to visit.</param>
        public virtual T Visit(ISyntax node)
        {
            return this.VisitActual(node);
        }

        /// <summary>Executes a visit of a SarifGrammar tree.</summary>
        /// <param name="node">The node to visit.</param>
        public virtual T VisitActual(ISyntax node)
        {
            if (node == null)
            {
                throw new ArgumentNullException("node");
            }

            switch (node.SyntaxKind)
            {
            case SarifGrammarKind.AnnotatedCodeLocation:
                return this.VisitAnnotatedCodeLocation((AnnotatedCodeLocation)node);
            case SarifGrammarKind.FileChange:
                return this.VisitFileChange((FileChange)node);
            case SarifGrammarKind.FileReference:
                return this.VisitFileReference((FileReference)node);
            case SarifGrammarKind.Fix:
                return this.VisitFix((Fix)node);
            case SarifGrammarKind.FormattedMessage:
                return this.VisitFormattedMessage((FormattedMessage)node);
            case SarifGrammarKind.Hash:
                return this.VisitHash((Hash)node);
            case SarifGrammarKind.Location:
                return this.VisitLocation((Location)node);
            case SarifGrammarKind.LogicalLocationComponent:
                return this.VisitLogicalLocationComponent((LogicalLocationComponent)node);
            case SarifGrammarKind.PhysicalLocationComponent:
                return this.VisitPhysicalLocationComponent((PhysicalLocationComponent)node);
            case SarifGrammarKind.Region:
                return this.VisitRegion((Region)node);
            case SarifGrammarKind.Replacement:
                return this.VisitReplacement((Replacement)node);
            case SarifGrammarKind.Result:
                return this.VisitResult((Result)node);
            case SarifGrammarKind.ResultLog:
                return this.VisitResultLog((ResultLog)node);
            case SarifGrammarKind.RuleDescriptor:
                return this.VisitRuleDescriptor((RuleDescriptor)node);
            case SarifGrammarKind.RunInfo:
                return this.VisitRunInfo((RunInfo)node);
            case SarifGrammarKind.RunLog:
                return this.VisitRunLog((RunLog)node);
            case SarifGrammarKind.ToolInfo:
                return this.VisitToolInfo((ToolInfo)node);
            default:
                return (T)(object)node;
            }
        }

        private void VisitNullChecked(ISyntax node)
        {
            if (node != null)
            {
                this.Visit(node);
            }
        }

        /// <summary>Visits a AnnotatedCodeLocation node in a SarifGrammar tree.</summary>
        /// <param name="node">A AnnotatedCodeLocation node to visit.</param>
        public virtual T VisitAnnotatedCodeLocation(AnnotatedCodeLocation node)
        {
            if (node != null)
            {
                if (node.PhysicalLocation != null)
                {
                    foreach (var value_0 in node.PhysicalLocation)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

            }

            return (T)(object)node;
        }

        /// <summary>Visits a FileChange node in a SarifGrammar tree.</summary>
        /// <param name="node">A FileChange node to visit.</param>
        public virtual T VisitFileChange(FileChange node)
        {
            if (node != null)
            {
                if (node.Replacements != null)
                {
                    foreach (var value_0 in node.Replacements)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

            }

            return (T)(object)node;
        }

        /// <summary>Visits a FileReference node in a SarifGrammar tree.</summary>
        /// <param name="node">A FileReference node to visit.</param>
        public virtual T VisitFileReference(FileReference node)
        {
            if (node != null)
            {
                if (node.Hashes != null)
                {
                    foreach (var value_0 in node.Hashes)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

            }

            return (T)(object)node;
        }

        /// <summary>Visits a Fix node in a SarifGrammar tree.</summary>
        /// <param name="node">A Fix node to visit.</param>
        public virtual T VisitFix(Fix node)
        {
            if (node != null)
            {
                if (node.FileChanges != null)
                {
                    foreach (var value_0 in node.FileChanges)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

            }

            return (T)(object)node;
        }

        /// <summary>Visits a FormattedMessage node in a SarifGrammar tree.</summary>
        /// <param name="node">A FormattedMessage node to visit.</param>
        public virtual T VisitFormattedMessage(FormattedMessage node)
        {
            if (node != null)
            {
            }

            return (T)(object)node;
        }

        /// <summary>Visits a Hash node in a SarifGrammar tree.</summary>
        /// <param name="node">A Hash node to visit.</param>
        public virtual T VisitHash(Hash node)
        {
            if (node != null)
            {
            }

            return (T)(object)node;
        }

        /// <summary>Visits a Location node in a SarifGrammar tree.</summary>
        /// <param name="node">A Location node to visit.</param>
        public virtual T VisitLocation(Location node)
        {
            if (node != null)
            {
                if (node.AnalysisTarget != null)
                {
                    foreach (var value_0 in node.AnalysisTarget)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

                if (node.ResultFile != null)
                {
                    foreach (var value_0 in node.ResultFile)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

                if (node.LogicalLocation != null)
                {
                    foreach (var value_0 in node.LogicalLocation)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

            }

            return (T)(object)node;
        }

        /// <summary>Visits a LogicalLocationComponent node in a SarifGrammar tree.</summary>
        /// <param name="node">A LogicalLocationComponent node to visit.</param>
        public virtual T VisitLogicalLocationComponent(LogicalLocationComponent node)
        {
            if (node != null)
            {
            }

            return (T)(object)node;
        }

        /// <summary>Visits a PhysicalLocationComponent node in a SarifGrammar tree.</summary>
        /// <param name="node">A PhysicalLocationComponent node to visit.</param>
        public virtual T VisitPhysicalLocationComponent(PhysicalLocationComponent node)
        {
            if (node != null)
            {
                this.VisitNullChecked(node.Region);
            }

            return (T)(object)node;
        }

        /// <summary>Visits a Region node in a SarifGrammar tree.</summary>
        /// <param name="node">A Region node to visit.</param>
        public virtual T VisitRegion(Region node)
        {
            if (node != null)
            {
            }

            return (T)(object)node;
        }

        /// <summary>Visits a Replacement node in a SarifGrammar tree.</summary>
        /// <param name="node">A Replacement node to visit.</param>
        public virtual T VisitReplacement(Replacement node)
        {
            if (node != null)
            {
            }

            return (T)(object)node;
        }

        /// <summary>Visits a Result node in a SarifGrammar tree.</summary>
        /// <param name="node">A Result node to visit.</param>
        public virtual T VisitResult(Result node)
        {
            if (node != null)
            {
                this.VisitNullChecked(node.FormattedMessage);
                if (node.Locations != null)
                {
                    foreach (var value_0 in node.Locations)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

                if (node.Stacks != null)
                {
                    foreach (var value_0 in node.Stacks)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

                if (node.ExecutionFlows != null)
                {
                    foreach (var value_0 in node.ExecutionFlows)
                    {
                        if (value_0 != null)
                        {
                            foreach (var value_1 in value_0)
                            {
                                this.VisitNullChecked(value_1);
                            }
                        }
                    }
                }

                if (node.RelatedLocations != null)
                {
                    foreach (var value_0 in node.RelatedLocations)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

                if (node.Fixes != null)
                {
                    foreach (var value_0 in node.Fixes)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

            }

            return (T)(object)node;
        }

        /// <summary>Visits a ResultLog node in a SarifGrammar tree.</summary>
        /// <param name="node">A ResultLog node to visit.</param>
        public virtual T VisitResultLog(ResultLog node)
        {
            if (node != null)
            {
                if (node.RunLogs != null)
                {
                    foreach (var value_0 in node.RunLogs)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

            }

            return (T)(object)node;
        }

        /// <summary>Visits a RuleDescriptor node in a SarifGrammar tree.</summary>
        /// <param name="node">A RuleDescriptor node to visit.</param>
        public virtual T VisitRuleDescriptor(RuleDescriptor node)
        {
            if (node != null)
            {
            }

            return (T)(object)node;
        }

        /// <summary>Visits a RunInfo node in a SarifGrammar tree.</summary>
        /// <param name="node">A RunInfo node to visit.</param>
        public virtual T VisitRunInfo(RunInfo node)
        {
            if (node != null)
            {
                if (node.AnalysisTargets != null)
                {
                    foreach (var value_0 in node.AnalysisTargets)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

            }

            return (T)(object)node;
        }

        /// <summary>Visits a RunLog node in a SarifGrammar tree.</summary>
        /// <param name="node">A RunLog node to visit.</param>
        public virtual T VisitRunLog(RunLog node)
        {
            if (node != null)
            {
                this.VisitNullChecked(node.ToolInfo);
                this.VisitNullChecked(node.RunInfo);
                if (node.Results != null)
                {
                    foreach (var value_0 in node.Results)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

            }

            return (T)(object)node;
        }

        /// <summary>Visits a ToolInfo node in a SarifGrammar tree.</summary>
        /// <param name="node">A ToolInfo node to visit.</param>
        public virtual T VisitToolInfo(ToolInfo node)
        {
            if (node != null)
            {
                if (node.RuleInfo != null)
                {
                    foreach (var value_0 in node.RuleInfo)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

            }

            return (T)(object)node;
        }
    }
    /// <summary>Rewriting visitor for a SarifGrammar tree.</summary>
    public abstract class SarifGrammarRewritingVisitor
    {
        /// <summary>Starts a rewriting visit of a SarifGrammar tree.</summary>
        /// <param name="node">The node to rewrite.</param>
        public virtual object Visit(ISyntax node)
        {
            return this.VisitActual(node);
        }

        /// <summary>Executes a visit of a SarifGrammar tree.</summary>
        /// <param name="node">The node to visit.</param>
        public virtual object VisitActual(ISyntax node)
        {
            if (node == null)
            {
                throw new ArgumentNullException("node");
            }

            switch (node.SyntaxKind)
            {
            case SarifGrammarKind.AnnotatedCodeLocation:
                return this.VisitAnnotatedCodeLocation((AnnotatedCodeLocation)node);
            case SarifGrammarKind.FileChange:
                return this.VisitFileChange((FileChange)node);
            case SarifGrammarKind.FileReference:
                return this.VisitFileReference((FileReference)node);
            case SarifGrammarKind.Fix:
                return this.VisitFix((Fix)node);
            case SarifGrammarKind.FormattedMessage:
                return this.VisitFormattedMessage((FormattedMessage)node);
            case SarifGrammarKind.Hash:
                return this.VisitHash((Hash)node);
            case SarifGrammarKind.Location:
                return this.VisitLocation((Location)node);
            case SarifGrammarKind.LogicalLocationComponent:
                return this.VisitLogicalLocationComponent((LogicalLocationComponent)node);
            case SarifGrammarKind.PhysicalLocationComponent:
                return this.VisitPhysicalLocationComponent((PhysicalLocationComponent)node);
            case SarifGrammarKind.Region:
                return this.VisitRegion((Region)node);
            case SarifGrammarKind.Replacement:
                return this.VisitReplacement((Replacement)node);
            case SarifGrammarKind.Result:
                return this.VisitResult((Result)node);
            case SarifGrammarKind.ResultLog:
                return this.VisitResultLog((ResultLog)node);
            case SarifGrammarKind.RuleDescriptor:
                return this.VisitRuleDescriptor((RuleDescriptor)node);
            case SarifGrammarKind.RunInfo:
                return this.VisitRunInfo((RunInfo)node);
            case SarifGrammarKind.RunLog:
                return this.VisitRunLog((RunLog)node);
            case SarifGrammarKind.ToolInfo:
                return this.VisitToolInfo((ToolInfo)node);
            default:
                return node;
            }
        }

        private T VisitNullChecked<T>(T node)
            where T : class, ISyntax
        {
            if (node == null)
            {
                return null;
            }

            return (T)this.Visit(node);
        }

        /// <summary>Rewrites a AnnotatedCodeLocation node in a SarifGrammar tree.</summary>
        /// <param name="node">A AnnotatedCodeLocation node to visit.</param>
        public virtual AnnotatedCodeLocation VisitAnnotatedCodeLocation(AnnotatedCodeLocation node)
        {
            if (node != null)
            {
                if (node.PhysicalLocation != null)
                {
                    for (int index_0 = 0; index_0 < node.PhysicalLocation.Count; ++index_0)
                    {
                        node.PhysicalLocation[index_0] = this.VisitNullChecked(node.PhysicalLocation[index_0]);
                    }
                }

            }

            return node;
        }

        /// <summary>Rewrites a FileChange node in a SarifGrammar tree.</summary>
        /// <param name="node">A FileChange node to visit.</param>
        public virtual FileChange VisitFileChange(FileChange node)
        {
            if (node != null)
            {
                if (node.Replacements != null)
                {
                    for (int index_0 = 0; index_0 < node.Replacements.Count; ++index_0)
                    {
                        node.Replacements[index_0] = this.VisitNullChecked(node.Replacements[index_0]);
                    }
                }

            }

            return node;
        }

        /// <summary>Rewrites a FileReference node in a SarifGrammar tree.</summary>
        /// <param name="node">A FileReference node to visit.</param>
        public virtual FileReference VisitFileReference(FileReference node)
        {
            if (node != null)
            {
                if (node.Hashes != null)
                {
                    for (int index_0 = 0; index_0 < node.Hashes.Count; ++index_0)
                    {
                        node.Hashes[index_0] = this.VisitNullChecked(node.Hashes[index_0]);
                    }
                }

            }

            return node;
        }

        /// <summary>Rewrites a Fix node in a SarifGrammar tree.</summary>
        /// <param name="node">A Fix node to visit.</param>
        public virtual Fix VisitFix(Fix node)
        {
            if (node != null)
            {
                if (node.FileChanges != null)
                {
                    for (int index_0 = 0; index_0 < node.FileChanges.Count; ++index_0)
                    {
                        node.FileChanges[index_0] = this.VisitNullChecked(node.FileChanges[index_0]);
                    }
                }

            }

            return node;
        }

        /// <summary>Rewrites a FormattedMessage node in a SarifGrammar tree.</summary>
        /// <param name="node">A FormattedMessage node to visit.</param>
        public virtual FormattedMessage VisitFormattedMessage(FormattedMessage node)
        {
            if (node != null)
            {
            }

            return node;
        }

        /// <summary>Rewrites a Hash node in a SarifGrammar tree.</summary>
        /// <param name="node">A Hash node to visit.</param>
        public virtual Hash VisitHash(Hash node)
        {
            if (node != null)
            {
            }

            return node;
        }

        /// <summary>Rewrites a Location node in a SarifGrammar tree.</summary>
        /// <param name="node">A Location node to visit.</param>
        public virtual Location VisitLocation(Location node)
        {
            if (node != null)
            {
                if (node.AnalysisTarget != null)
                {
                    for (int index_0 = 0; index_0 < node.AnalysisTarget.Count; ++index_0)
                    {
                        node.AnalysisTarget[index_0] = this.VisitNullChecked(node.AnalysisTarget[index_0]);
                    }
                }

                if (node.ResultFile != null)
                {
                    for (int index_0 = 0; index_0 < node.ResultFile.Count; ++index_0)
                    {
                        node.ResultFile[index_0] = this.VisitNullChecked(node.ResultFile[index_0]);
                    }
                }

                if (node.LogicalLocation != null)
                {
                    for (int index_0 = 0; index_0 < node.LogicalLocation.Count; ++index_0)
                    {
                        node.LogicalLocation[index_0] = this.VisitNullChecked(node.LogicalLocation[index_0]);
                    }
                }

            }

            return node;
        }

        /// <summary>Rewrites a LogicalLocationComponent node in a SarifGrammar tree.</summary>
        /// <param name="node">A LogicalLocationComponent node to visit.</param>
        public virtual LogicalLocationComponent VisitLogicalLocationComponent(LogicalLocationComponent node)
        {
            if (node != null)
            {
            }

            return node;
        }

        /// <summary>Rewrites a PhysicalLocationComponent node in a SarifGrammar tree.</summary>
        /// <param name="node">A PhysicalLocationComponent node to visit.</param>
        public virtual PhysicalLocationComponent VisitPhysicalLocationComponent(PhysicalLocationComponent node)
        {
            if (node != null)
            {
                node.Region = this.VisitNullChecked(node.Region);
            }

            return node;
        }

        /// <summary>Rewrites a Region node in a SarifGrammar tree.</summary>
        /// <param name="node">A Region node to visit.</param>
        public virtual Region VisitRegion(Region node)
        {
            if (node != null)
            {
            }

            return node;
        }

        /// <summary>Rewrites a Replacement node in a SarifGrammar tree.</summary>
        /// <param name="node">A Replacement node to visit.</param>
        public virtual Replacement VisitReplacement(Replacement node)
        {
            if (node != null)
            {
            }

            return node;
        }

        /// <summary>Rewrites a Result node in a SarifGrammar tree.</summary>
        /// <param name="node">A Result node to visit.</param>
        public virtual Result VisitResult(Result node)
        {
            if (node != null)
            {
                node.FormattedMessage = this.VisitNullChecked(node.FormattedMessage);
                if (node.Locations != null)
                {
                    for (int index_0 = 0; index_0 < node.Locations.Count; ++index_0)
                    {
                        node.Locations[index_0] = this.VisitNullChecked(node.Locations[index_0]);
                    }
                }

                if (node.Stacks != null)
                {
                    for (int index_0 = 0; index_0 < node.Stacks.Count; ++index_0)
                    {
                        node.Stacks[index_0] = this.VisitNullChecked(node.Stacks[index_0]);
                    }
                }

                if (node.ExecutionFlows != null)
                {
                    for (int index_0 = 0; index_0 < node.ExecutionFlows.Count; ++index_0)
                    {
                        var value_0 = node.ExecutionFlows[index_0];
                        if (value_0 != null)
                        {
                            for (int index_1 = 0; index_1 < value_0.Count; ++index_1)
                            {
                                value_0[index_1] = this.VisitNullChecked(value_0[index_1]);
                            }
                        }
                    }
                }

                if (node.RelatedLocations != null)
                {
                    for (int index_0 = 0; index_0 < node.RelatedLocations.Count; ++index_0)
                    {
                        node.RelatedLocations[index_0] = this.VisitNullChecked(node.RelatedLocations[index_0]);
                    }
                }

                if (node.Fixes != null)
                {
                    for (int index_0 = 0; index_0 < node.Fixes.Count; ++index_0)
                    {
                        node.Fixes[index_0] = this.VisitNullChecked(node.Fixes[index_0]);
                    }
                }

            }

            return node;
        }

        /// <summary>Rewrites a ResultLog node in a SarifGrammar tree.</summary>
        /// <param name="node">A ResultLog node to visit.</param>
        public virtual ResultLog VisitResultLog(ResultLog node)
        {
            if (node != null)
            {
                if (node.RunLogs != null)
                {
                    for (int index_0 = 0; index_0 < node.RunLogs.Count; ++index_0)
                    {
                        node.RunLogs[index_0] = this.VisitNullChecked(node.RunLogs[index_0]);
                    }
                }

            }

            return node;
        }

        /// <summary>Rewrites a RuleDescriptor node in a SarifGrammar tree.</summary>
        /// <param name="node">A RuleDescriptor node to visit.</param>
        public virtual RuleDescriptor VisitRuleDescriptor(RuleDescriptor node)
        {
            if (node != null)
            {
            }

            return node;
        }

        /// <summary>Rewrites a RunInfo node in a SarifGrammar tree.</summary>
        /// <param name="node">A RunInfo node to visit.</param>
        public virtual RunInfo VisitRunInfo(RunInfo node)
        {
            if (node != null)
            {
                if (node.AnalysisTargets != null)
                {
                    for (int index_0 = 0; index_0 < node.AnalysisTargets.Count; ++index_0)
                    {
                        node.AnalysisTargets[index_0] = this.VisitNullChecked(node.AnalysisTargets[index_0]);
                    }
                }

            }

            return node;
        }

        /// <summary>Rewrites a RunLog node in a SarifGrammar tree.</summary>
        /// <param name="node">A RunLog node to visit.</param>
        public virtual RunLog VisitRunLog(RunLog node)
        {
            if (node != null)
            {
                node.ToolInfo = this.VisitNullChecked(node.ToolInfo);
                node.RunInfo = this.VisitNullChecked(node.RunInfo);
                if (node.Results != null)
                {
                    for (int index_0 = 0; index_0 < node.Results.Count; ++index_0)
                    {
                        node.Results[index_0] = this.VisitNullChecked(node.Results[index_0]);
                    }
                }

            }

            return node;
        }

        /// <summary>Rewrites a ToolInfo node in a SarifGrammar tree.</summary>
        /// <param name="node">A ToolInfo node to visit.</param>
        public virtual ToolInfo VisitToolInfo(ToolInfo node)
        {
            if (node != null)
            {
                if (node.RuleInfo != null)
                {
                    for (int index_0 = 0; index_0 < node.RuleInfo.Count; ++index_0)
                    {
                        node.RuleInfo[index_0] = this.VisitNullChecked(node.RuleInfo[index_0]);
                    }
                }

            }

            return node;
        }
    }
}
// End of generated code.

