// *********************************************************
// *                                                       *
// *   Copyright (C) Microsoft. All rights reserved.       *
// *                                                       *
// *********************************************************

//----------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Input Grammar      : ToolIssuesLog
//     Input Grammar file : D:\src\sarif-sdk\src\StaticAnalysisResultsInterchangeFormat\GrammarFiles\SarifFormat.g4
//     
//     Changes to this file may cause incorrect behavior and 
//     will be lost when the code is regenerated.
// </auto-generated>
//----------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Text;

namespace Microsoft.CodeAnalysis.StaticAnalysisResultsInterchangeFormat.DataContracts
{
    /// <summary>An enumeration containing all the types which implement <see cref="ISyntax" />.</summary>
    public enum ToolIssuesLogKind
    {
        /// <summary>An uninitialized kind.</summary>
        None,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type ExecutionFlowEntry.</summary>
        ExecutionFlowEntry,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type FileReference.</summary>
        FileReference,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type Hash.</summary>
        Hash,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type Issue.</summary>
        Issue,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type IssueLog.</summary>
        IssueLog,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type Location.</summary>
        Location,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type LogicalLocationComponent.</summary>
        LogicalLocationComponent,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type PhysicalLocationComponent.</summary>
        PhysicalLocationComponent,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type Region.</summary>
        Region,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type RunInfo.</summary>
        RunInfo,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type RunLog.</summary>
        RunLog,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type ToolInfo.</summary>
        ToolInfo,
    }

    /// <summary>An interface for all types generated from the grammar ToolIssuesLog.</summary>
    public interface ISyntax
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        ToolIssuesLogKind Kind { get; }

        /// <summary>Makes a deep copy of this instance.</summary>
        ISyntax DeepClone();
    }

    /// <summary>
    /// A single physical location visited in an execution flow.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class ExecutionFlowEntry : ISyntax, IEquatable<ExecutionFlowEntry>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public ToolIssuesLogKind Kind { get { return ToolIssuesLogKind.ExecutionFlowEntry; } }

        /// <summary>
        /// A set of places to which this excution flow entry refers. These locations are of equal
        /// priority; for example, one entry may be the source code location while another is the
        /// assembly or IL location.
        /// </summary>
        [DataMember(Name="physicalLocations", IsRequired = true)]
        public IList<IList<PhysicalLocationComponent>> PhysicalLocations { get; set; }

        /// <summary>
        /// A message associated with this execution flow entry, if applicable.
        /// </summary>
        [DataMember(Name="message", IsRequired = false, EmitDefaultValue = false)]
        public string Message { get; set; }

        private void Init(IEnumerable<IEnumerable<PhysicalLocationComponent>> physicalLocationsArg, string messageArg)
        {
            if (physicalLocationsArg != null)
            {
                var destination_0 = new List<IList<PhysicalLocationComponent>>();
                if (physicalLocationsArg != null)
                {
                    foreach (var value_0 in physicalLocationsArg)
                    {
                        var destination_1 = new List<PhysicalLocationComponent>();
                        if (value_0 != null)
                        {
                            foreach (var value_1 in value_0)
                            {
                                if (value_1 == null)
                                {
                                    destination_1.Add(null);
                                }
                                else
                                {
                                    destination_1.Add(new PhysicalLocationComponent(value_1));
                                }
                            }
                        }

                        destination_0.Add(destination_1);
                    }
                }

                this.PhysicalLocations = destination_0;
            }
            if (messageArg != null)
            {
                this.Message = messageArg;
            }
        }

        /// <summary>Initializes a new instance of the <see cref="ExecutionFlowEntry" /> class.</summary>
        public ExecutionFlowEntry()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="ExecutionFlowEntry" /> class with the supplied data.</summary>
        /// <param name="physicalLocationsArg">An initialization value for the <see cref="P:PhysicalLocations" /> member.</param>
        /// <param name="messageArg">An initialization value for the <see cref="P:Message" /> member.</param>
        public ExecutionFlowEntry(IEnumerable<IEnumerable<PhysicalLocationComponent>> physicalLocationsArg, string messageArg)
        {
            this.Init(
                physicalLocationsArg, 
                messageArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="ExecutionFlowEntry" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public ExecutionFlowEntry(ExecutionFlowEntry other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.PhysicalLocations, 
                other.Message
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public ExecutionFlowEntry DeepClone()
        {
            return (ExecutionFlowEntry)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new ExecutionFlowEntry(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                foreach (var value_0 in this.PhysicalLocations)
                {
                    result = result * 31;
                    if (value_0 != null)
                    {
                        foreach (var value_1 in value_0)
                        {
                            result = result * 31;
                            if (value_1 != null)
                            {
                                result = (result * 31) + value_1.GetHashCode();
                            }
                        }
                    }
                }

                if (this.Message != null)
                {
                    result = (result * 31) + this.Message.GetHashCode();
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as ExecutionFlowEntry);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(ExecutionFlowEntry other)
        {
            if (other == null)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.PhysicalLocations, other.PhysicalLocations))
            {
                if (this.PhysicalLocations == null || other.PhysicalLocations == null)
                {
                    return false;
                }

                if (this.PhysicalLocations.Count != other.PhysicalLocations.Count)
                {
                    return false;
                }

                int max_0 = this.PhysicalLocations.Count;
                for (int index_0 = 0; index_0 < max_0; ++index_0)
                {
                    var value_2 = this.PhysicalLocations[index_0];
                    var value_3 = other.PhysicalLocations[index_0];
                    if (!global::System.Object.ReferenceEquals(value_2, value_3))
                    {
                        if (value_2 == null || value_3 == null)
                        {
                            return false;
                        }

                        if (value_2.Count != value_3.Count)
                        {
                            return false;
                        }

                        int max_1 = value_2.Count;
                        for (int index_1 = 0; index_1 < max_1; ++index_1)
                        {
                            var value_4 = value_2[index_1];
                            var value_5 = value_3[index_1];
                            if (!global::System.Object.Equals(value_4, value_5))
                            {
                                return false;
                            }
                        }
                    }
                }
            }

            if (this.Message != other.Message)
            {
                return false;
            }

            return true;
        }
    }

    /// <summary>
    /// A fileReference object represents a single file
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class FileReference : ISyntax, IEquatable<FileReference>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public ToolIssuesLogKind Kind { get { return ToolIssuesLogKind.FileReference; } }

        /// <summary>
        /// The location of the file as a valid URI
        /// </summary>
        [DataMember(Name="uri", IsRequired = true)]
        public global::System.Uri Uri { get; set; }

        /// <summary>
        /// An array of hash objects (�6.8), each of which specifies a hashed value for the file specified
        /// by the uri property (�6.7.2), along with the name of the algorithm used to compute the hash.
        /// </summary>
        [DataMember(Name="hashes", IsRequired = true)]
        public IList<Hash> Hashes { get; set; }

        private void Init(global::System.Uri uriArg, IEnumerable<Hash> hashesArg)
        {
            if (uriArg != null)
            {
                this.Uri = new global::System.Uri(uriArg.OriginalString, uriArg.IsAbsoluteUri ? global::System.UriKind.Absolute : global::System.UriKind.Relative);
            }
            if (hashesArg != null)
            {
                var destination_0 = new List<Hash>();
                if (hashesArg != null)
                {
                    foreach (var value_0 in hashesArg)
                    {
                        if (value_0 == null)
                        {
                            destination_0.Add(null);
                        }
                        else
                        {
                            destination_0.Add(new Hash(value_0));
                        }
                    }
                }

                this.Hashes = destination_0;
            }
        }

        /// <summary>Initializes a new instance of the <see cref="FileReference" /> class.</summary>
        public FileReference()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="FileReference" /> class with the supplied data.</summary>
        /// <param name="uriArg">An initialization value for the <see cref="P:Uri" /> member.</param>
        /// <param name="hashesArg">An initialization value for the <see cref="P:Hashes" /> member.</param>
        public FileReference(global::System.Uri uriArg, IEnumerable<Hash> hashesArg)
        {
            this.Init(
                uriArg, 
                hashesArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="FileReference" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public FileReference(FileReference other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.Uri, 
                other.Hashes
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public FileReference DeepClone()
        {
            return (FileReference)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new FileReference(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                if (this.Uri != null)
                {
                    result = (result * 31) + this.Uri.GetHashCode();
                }
                foreach (var value_0 in this.Hashes)
                {
                    result = result * 31;
                    if (value_0 != null)
                    {
                        result = (result * 31) + value_0.GetHashCode();
                    }
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as FileReference);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(FileReference other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.Uri != other.Uri)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.Hashes, other.Hashes))
            {
                if (this.Hashes == null || other.Hashes == null)
                {
                    return false;
                }

                if (this.Hashes.Count != other.Hashes.Count)
                {
                    return false;
                }

                int max_0 = this.Hashes.Count;
                for (int index_0 = 0; index_0 < max_0; ++index_0)
                {
                    var value_1 = this.Hashes[index_0];
                    var value_2 = other.Hashes[index_0];
                    if (!global::System.Object.Equals(value_1, value_2))
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }

    /// <summary>
    /// A hash value of some file or collection of files, together with the algorithm used to compute the hash.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class Hash : ISyntax, IEquatable<Hash>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public ToolIssuesLogKind Kind { get { return ToolIssuesLogKind.Hash; } }

        /// <summary>
        /// The hash value of some file or collection of files, computed by the algorithm named in the algorithm property.
        /// </summary>
        [DataMember(Name="value", IsRequired = true)]
        public string Value { get; set; }

        /// <summary>
        /// A string specifying the name of the algorithm used to compute the hash value specified in the value property.
        /// This shall be one of the following: BLAKE-256, BLAKE-512, ECOH, FSB, GOST, Gr�stl, HAS-160, HAVAL, JH, MD2,
        /// MD4, MD5, MD6, RadioGat�n, RIPEMD, RIPEMD-128, RIPEMD-160, RIPEMD-320, SHA-1, SHA-224, SHA-256, SHA-384,
        /// SHA-512, SHA-3, Skein, Snefru, Spectral Hash, SWIFFT, Tiger, Whirlpool.
        /// </summary>
        [DataMember(Name="algorithm", IsRequired = true)]
        public string Algorithm { get; set; }

        private void Init(string valueArg, string algorithmArg)
        {
            if (valueArg != null)
            {
                this.Value = valueArg;
            }
            if (algorithmArg != null)
            {
                this.Algorithm = algorithmArg;
            }
        }

        /// <summary>Initializes a new instance of the <see cref="Hash" /> class.</summary>
        public Hash()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="Hash" /> class with the supplied data.</summary>
        /// <param name="valueArg">An initialization value for the <see cref="P:Value" /> member.</param>
        /// <param name="algorithmArg">An initialization value for the <see cref="P:Algorithm" /> member.</param>
        public Hash(string valueArg, string algorithmArg)
        {
            this.Init(
                valueArg, 
                algorithmArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="Hash" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public Hash(Hash other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.Value, 
                other.Algorithm
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public Hash DeepClone()
        {
            return (Hash)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new Hash(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                if (this.Value != null)
                {
                    result = (result * 31) + this.Value.GetHashCode();
                }
                if (this.Algorithm != null)
                {
                    result = (result * 31) + this.Algorithm.GetHashCode();
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as Hash);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(Hash other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.Value != other.Value)
            {
                return false;
            }

            if (this.Algorithm != other.Algorithm)
            {
                return false;
            }

            return true;
        }
    }

    /// <summary>
    /// Represents one or more observations about an analysis target produced by a static analysis tool.
    /// </summary>
    /// <remarks>
    /// An issue frequently, but not always, represents a code defect.
    /// </remarks>
    [DataContract]
    [CompilerGenerated]
    public sealed class Issue : ISyntax, IEquatable<Issue>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public ToolIssuesLogKind Kind { get { return ToolIssuesLogKind.Issue; } }

        /// <summary>
        /// A string that baselining mechanisms can merge with other data to help uniquely identify this issue, run-over-run.
        /// </summary>
        [DataMember(Name="toolFingerprint", IsRequired = false, EmitDefaultValue = false)]
        public string ToolFingerprint { get; set; }

        /// <summary>
        /// An opaque, stable identifier that uniquely identifies the specific rule associated with
        /// the issue(e.g., CA2001).
        /// </summary>
        [DataMember(Name="ruleId", IsRequired = false, EmitDefaultValue = false)]
        public string RuleId { get; set; }

        /// <summary>
        /// Specifies one or more peer locations where an issue is located. Note that this is not used
        /// to point to multiple instances of the same issue; separate instances should have separate
        /// issue objects. For example, a misspelled partial class in C# may list all the source
        /// lines on which the partial class is declared as separate top-level locations. However, two
        /// independent misspellings of the same word need to be top level issues.
        /// </summary>
        [DataMember(Name="locations", IsRequired = true)]
        public IList<Location> Locations { get; set; }

        /// <summary>
        /// A short description that summarizes an issue to the user in one or two lines.
        /// </summary>
        [DataMember(Name="shortMessage", IsRequired = false, EmitDefaultValue = false)]
        public string ShortMessage { get; set; }

        /// <summary>
        /// A string that comprehensively describes the issue to the users.
        /// </summary>
        [DataMember(Name="fullMessage", IsRequired = true)]
        public string FullMessage { get; set; }

        /// <summary>
        /// A grouped set of locations, if available, that represent stacks associated with this issue.
        /// </summary>
        [DataMember(Name="stacks", IsRequired = false, EmitDefaultValue = false)]
        public IList<IList<ExecutionFlowEntry>> Stacks { get; set; }

        /// <summary>
        /// A grouped set of location, if available, that comprise annotated
        /// execution flows through code which are associated with this issue.
        /// </summary>
        [DataMember(Name="executionFlows", IsRequired = false, EmitDefaultValue = false)]
        public IList<IList<ExecutionFlowEntry>> ExecutionFlows { get; set; }

        /// <summary>
        /// A flag that indicates whether or not this issue was suppressed in source code.
        /// </summary>
        [DataMember(Name="isSuppressedInSource", IsRequired = false, EmitDefaultValue = false)]
        public bool IsSuppressedInSource { get; set; }

        /// <summary>
        /// Key/value pairs that additional details about the issue.
        /// </summary>
        [DataMember(Name="properties", IsRequired = false, EmitDefaultValue = false)]
        public global::System.Collections.Generic.Dictionary<string, string> Properties { get; set; }

        private void Init(string toolFingerprintArg, string ruleIdArg, IEnumerable<Location> locationsArg, string shortMessageArg, string fullMessageArg, IEnumerable<IEnumerable<ExecutionFlowEntry>> stacksArg, IEnumerable<IEnumerable<ExecutionFlowEntry>> executionFlowsArg, bool isSuppressedInSourceArg, global::System.Collections.Generic.Dictionary<string, string> propertiesArg)
        {
            if (toolFingerprintArg != null)
            {
                this.ToolFingerprint = toolFingerprintArg;
            }
            if (ruleIdArg != null)
            {
                this.RuleId = ruleIdArg;
            }
            if (locationsArg != null)
            {
                var destination_0 = new List<Location>();
                if (locationsArg != null)
                {
                    foreach (var value_0 in locationsArg)
                    {
                        if (value_0 == null)
                        {
                            destination_0.Add(null);
                        }
                        else
                        {
                            destination_0.Add(new Location(value_0));
                        }
                    }
                }

                this.Locations = destination_0;
            }
            if (shortMessageArg != null)
            {
                this.ShortMessage = shortMessageArg;
            }
            if (fullMessageArg != null)
            {
                this.FullMessage = fullMessageArg;
            }
            if (stacksArg != null)
            {
                var destination_1 = new List<IList<ExecutionFlowEntry>>();
                if (stacksArg != null)
                {
                    foreach (var value_1 in stacksArg)
                    {
                        var destination_2 = new List<ExecutionFlowEntry>();
                        if (value_1 != null)
                        {
                            foreach (var value_2 in value_1)
                            {
                                if (value_2 == null)
                                {
                                    destination_2.Add(null);
                                }
                                else
                                {
                                    destination_2.Add(new ExecutionFlowEntry(value_2));
                                }
                            }
                        }

                        destination_1.Add(destination_2);
                    }
                }

                this.Stacks = destination_1;
            }
            if (executionFlowsArg != null)
            {
                var destination_3 = new List<IList<ExecutionFlowEntry>>();
                if (executionFlowsArg != null)
                {
                    foreach (var value_3 in executionFlowsArg)
                    {
                        var destination_4 = new List<ExecutionFlowEntry>();
                        if (value_3 != null)
                        {
                            foreach (var value_4 in value_3)
                            {
                                if (value_4 == null)
                                {
                                    destination_4.Add(null);
                                }
                                else
                                {
                                    destination_4.Add(new ExecutionFlowEntry(value_4));
                                }
                            }
                        }

                        destination_3.Add(destination_4);
                    }
                }

                this.ExecutionFlows = destination_3;
            }
            this.IsSuppressedInSource = isSuppressedInSourceArg;
            if (propertiesArg != null)
            {
                this.Properties = new global::System.Collections.Generic.Dictionary<string, string>(propertiesArg);
            }
        }

        /// <summary>Initializes a new instance of the <see cref="Issue" /> class.</summary>
        public Issue()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="Issue" /> class with the supplied data.</summary>
        /// <param name="toolFingerprintArg">An initialization value for the <see cref="P:ToolFingerprint" /> member.</param>
        /// <param name="ruleIdArg">An initialization value for the <see cref="P:RuleId" /> member.</param>
        /// <param name="locationsArg">An initialization value for the <see cref="P:Locations" /> member.</param>
        /// <param name="shortMessageArg">An initialization value for the <see cref="P:ShortMessage" /> member.</param>
        /// <param name="fullMessageArg">An initialization value for the <see cref="P:FullMessage" /> member.</param>
        /// <param name="stacksArg">An initialization value for the <see cref="P:Stacks" /> member.</param>
        /// <param name="executionFlowsArg">An initialization value for the <see cref="P:ExecutionFlows" /> member.</param>
        /// <param name="isSuppressedInSourceArg">An initialization value for the <see cref="P:IsSuppressedInSource" /> member.</param>
        /// <param name="propertiesArg">An initialization value for the <see cref="P:Properties" /> member.</param>
        public Issue(string toolFingerprintArg, string ruleIdArg, IEnumerable<Location> locationsArg, string shortMessageArg, string fullMessageArg, IEnumerable<IEnumerable<ExecutionFlowEntry>> stacksArg, IEnumerable<IEnumerable<ExecutionFlowEntry>> executionFlowsArg, bool isSuppressedInSourceArg, global::System.Collections.Generic.Dictionary<string, string> propertiesArg)
        {
            this.Init(
                toolFingerprintArg, 
                ruleIdArg, 
                locationsArg, 
                shortMessageArg, 
                fullMessageArg, 
                stacksArg, 
                executionFlowsArg, 
                isSuppressedInSourceArg, 
                propertiesArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="Issue" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public Issue(Issue other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.ToolFingerprint, 
                other.RuleId, 
                other.Locations, 
                other.ShortMessage, 
                other.FullMessage, 
                other.Stacks, 
                other.ExecutionFlows, 
                other.IsSuppressedInSource, 
                other.Properties
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public Issue DeepClone()
        {
            return (Issue)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new Issue(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                if (this.ToolFingerprint != null)
                {
                    result = (result * 31) + this.ToolFingerprint.GetHashCode();
                }
                if (this.RuleId != null)
                {
                    result = (result * 31) + this.RuleId.GetHashCode();
                }
                foreach (var value_0 in this.Locations)
                {
                    result = result * 31;
                    if (value_0 != null)
                    {
                        result = (result * 31) + value_0.GetHashCode();
                    }
                }

                if (this.ShortMessage != null)
                {
                    result = (result * 31) + this.ShortMessage.GetHashCode();
                }
                if (this.FullMessage != null)
                {
                    result = (result * 31) + this.FullMessage.GetHashCode();
                }
                foreach (var value_1 in this.Stacks)
                {
                    result = result * 31;
                    if (value_1 != null)
                    {
                        foreach (var value_2 in value_1)
                        {
                            result = result * 31;
                            if (value_2 != null)
                            {
                                result = (result * 31) + value_2.GetHashCode();
                            }
                        }
                    }
                }

                foreach (var value_3 in this.ExecutionFlows)
                {
                    result = result * 31;
                    if (value_3 != null)
                    {
                        foreach (var value_4 in value_3)
                        {
                            result = result * 31;
                            if (value_4 != null)
                            {
                                result = (result * 31) + value_4.GetHashCode();
                            }
                        }
                    }
                }

                if (this.IsSuppressedInSource)
                {
                    result = (result * 31) + 1;
                }
                if (this.Properties != null)
                {
                    // Use xor for dictionaries to be order-independent
                    int xor_0 = 0;
                    foreach (var value_5 in this.Properties)
                    {
                        xor_0 ^= (value_5.Key ?? String.Empty).GetHashCode();
                        xor_0 ^= (value_5.Value ?? String.Empty).GetHashCode();
                    }

                    result = (result * 31) + xor_0;
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as Issue);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(Issue other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.ToolFingerprint != other.ToolFingerprint)
            {
                return false;
            }

            if (this.RuleId != other.RuleId)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.Locations, other.Locations))
            {
                if (this.Locations == null || other.Locations == null)
                {
                    return false;
                }

                if (this.Locations.Count != other.Locations.Count)
                {
                    return false;
                }

                int max_0 = this.Locations.Count;
                for (int index_0 = 0; index_0 < max_0; ++index_0)
                {
                    var value_6 = this.Locations[index_0];
                    var value_7 = other.Locations[index_0];
                    if (!global::System.Object.Equals(value_6, value_7))
                    {
                        return false;
                    }
                }
            }

            if (this.ShortMessage != other.ShortMessage)
            {
                return false;
            }

            if (this.FullMessage != other.FullMessage)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.Stacks, other.Stacks))
            {
                if (this.Stacks == null || other.Stacks == null)
                {
                    return false;
                }

                if (this.Stacks.Count != other.Stacks.Count)
                {
                    return false;
                }

                int max_1 = this.Stacks.Count;
                for (int index_1 = 0; index_1 < max_1; ++index_1)
                {
                    var value_8 = this.Stacks[index_1];
                    var value_9 = other.Stacks[index_1];
                    if (!global::System.Object.ReferenceEquals(value_8, value_9))
                    {
                        if (value_8 == null || value_9 == null)
                        {
                            return false;
                        }

                        if (value_8.Count != value_9.Count)
                        {
                            return false;
                        }

                        int max_2 = value_8.Count;
                        for (int index_2 = 0; index_2 < max_2; ++index_2)
                        {
                            var value_10 = value_8[index_2];
                            var value_11 = value_9[index_2];
                            if (!global::System.Object.Equals(value_10, value_11))
                            {
                                return false;
                            }
                        }
                    }
                }
            }

            if (!global::System.Object.ReferenceEquals(this.ExecutionFlows, other.ExecutionFlows))
            {
                if (this.ExecutionFlows == null || other.ExecutionFlows == null)
                {
                    return false;
                }

                if (this.ExecutionFlows.Count != other.ExecutionFlows.Count)
                {
                    return false;
                }

                int max_3 = this.ExecutionFlows.Count;
                for (int index_3 = 0; index_3 < max_3; ++index_3)
                {
                    var value_12 = this.ExecutionFlows[index_3];
                    var value_13 = other.ExecutionFlows[index_3];
                    if (!global::System.Object.ReferenceEquals(value_12, value_13))
                    {
                        if (value_12 == null || value_13 == null)
                        {
                            return false;
                        }

                        if (value_12.Count != value_13.Count)
                        {
                            return false;
                        }

                        int max_4 = value_12.Count;
                        for (int index_4 = 0; index_4 < max_4; ++index_4)
                        {
                            var value_14 = value_12[index_4];
                            var value_15 = value_13[index_4];
                            if (!global::System.Object.Equals(value_14, value_15))
                            {
                                return false;
                            }
                        }
                    }
                }
            }

            if (this.IsSuppressedInSource != other.IsSuppressedInSource)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.Properties, other.Properties))
            {
                if (this.Properties == null || other.Properties == null || this.Properties.Count != other.Properties.Count)
                {
                    return false;
                }
                foreach (var value_16 in this.Properties)
                {
                    string value_17;
                    if (!other.Properties.TryGetValue(value_16.Key, out value_17) || !global::System.Object.Equals(value_16.Value, value_17))
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }

    /// <summary>
    /// An SARIF format log.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class IssueLog : ISyntax, IEquatable<IssueLog>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public ToolIssuesLogKind Kind { get { return ToolIssuesLogKind.IssueLog; } }

        /// <summary>
        /// The SARIF tool format version of this log file. This value should be set to 0.3, currently.
        /// This is the second proposed revision of a file format that is not yet completely finalized.
        /// </summary>
        [DataMember(Name="version", IsRequired = true)]
        public global::System.Version Version { get; set; }

        /// <summary>
        /// The set of runLogs contained in this SARIF log.
        /// </summary>
        [DataMember(Name="runLogs", IsRequired = true)]
        public IList<RunLog> RunLogs { get; set; }

        private void Init(global::System.Version versionArg, IEnumerable<RunLog> runLogsArg)
        {
            if (versionArg != null)
            {
                this.Version = (global::System.Version)versionArg.Clone();
            }
            if (runLogsArg != null)
            {
                var destination_0 = new List<RunLog>();
                if (runLogsArg != null)
                {
                    foreach (var value_0 in runLogsArg)
                    {
                        if (value_0 == null)
                        {
                            destination_0.Add(null);
                        }
                        else
                        {
                            destination_0.Add(new RunLog(value_0));
                        }
                    }
                }

                this.RunLogs = destination_0;
            }
        }

        /// <summary>Initializes a new instance of the <see cref="IssueLog" /> class.</summary>
        public IssueLog()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="IssueLog" /> class with the supplied data.</summary>
        /// <param name="versionArg">An initialization value for the <see cref="P:Version" /> member.</param>
        /// <param name="runLogsArg">An initialization value for the <see cref="P:RunLogs" /> member.</param>
        public IssueLog(global::System.Version versionArg, IEnumerable<RunLog> runLogsArg)
        {
            this.Init(
                versionArg, 
                runLogsArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="IssueLog" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public IssueLog(IssueLog other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.Version, 
                other.RunLogs
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public IssueLog DeepClone()
        {
            return (IssueLog)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new IssueLog(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                if (this.Version != null)
                {
                    result = (result * 31) + this.Version.GetHashCode();
                }
                foreach (var value_0 in this.RunLogs)
                {
                    result = result * 31;
                    if (value_0 != null)
                    {
                        result = (result * 31) + value_0.GetHashCode();
                    }
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as IssueLog);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(IssueLog other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.Version != other.Version)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.RunLogs, other.RunLogs))
            {
                if (this.RunLogs == null || other.RunLogs == null)
                {
                    return false;
                }

                if (this.RunLogs.Count != other.RunLogs.Count)
                {
                    return false;
                }

                int max_0 = this.RunLogs.Count;
                for (int index_0 = 0; index_0 < max_0; ++index_0)
                {
                    var value_1 = this.RunLogs[index_0];
                    var value_2 = other.RunLogs[index_0];
                    if (!global::System.Object.Equals(value_1, value_2))
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }

    /// <summary>
    /// Specifies a location within a file, or within an object nested within a file
    /// (such as a location within an assembly contained in an appx file).
    /// At least one of [AnalysisTarget, IssueFile] MUST be filled in. If they are the same,
    /// fill out only AnalysisTarget.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class Location : ISyntax, IEquatable<Location>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public ToolIssuesLogKind Kind { get { return ToolIssuesLogKind.Location; } }

        /// <summary>
        /// A source file that is associated with the item that the static analysis tool scanned. This
        /// may be a .dll in the case of a binary analysis tool like FxCop, or a C++ file in the case
        /// of a source analysis tool like PREfast. Note that the defect may not actually occur in this file.
        /// </summary>
        [DataMember(Name="analysisTarget", IsRequired = false, EmitDefaultValue = false)]
        public IList<PhysicalLocationComponent> AnalysisTarget { get; set; }

        /// <summary>
        /// A source file that is associated with the current issue if and only if that is not the
        /// same as the analysis target. This member will populated or not, in many cases, depending
        /// on whether PDBs associated with the analysis target are available. Examples include a C# file
        /// in the FxCop-like binary analysis case, or possibly a .H C++ file in the case of a source
        /// analysis tool like PREfast.
        /// </summary>
        [DataMember(Name="issueFile", IsRequired = false, EmitDefaultValue = false)]
        public IList<PhysicalLocationComponent> IssueFile { get; set; }

        /// <summary>
        /// A string containing the language-specific logical name of the location where the issue occurs; e.g.
        ///     C: Foo
        ///     C++: Namespace::Class::MemberFunction(int, double) const&amp;&amp;
        ///     C++: Namespace::NonmemberFunction(int, double)
        ///     C#: SecurityCryptographyRuleTests.DESCannotBeUsed.EncryptData(System.String,System.String,System.Byte[],System.Byte[])
        /// </summary>
        [DataMember(Name="fullyQualifiedLogicalName", IsRequired = false, EmitDefaultValue = false)]
        public string FullyQualifiedLogicalName { get; set; }

        /// <summary>
        /// An object that specifies the logical namespace / function / etc location.
        /// </summary>
        [DataMember(Name="logicalLocation", IsRequired = false, EmitDefaultValue = false)]
        public IList<LogicalLocationComponent> LogicalLocation { get; set; }

        /// <summary>
        /// Key/value pairs that provide additional information about this location.
        /// This might be used to annotate specific stack frames or points in code
        /// with additional information, such as assumed values of variables at that
        /// point of execution, etc.
        /// </summary>
        [DataMember(Name="properties", IsRequired = false, EmitDefaultValue = false)]
        public global::System.Collections.Generic.Dictionary<string, string> Properties { get; set; }

        private void Init(IEnumerable<PhysicalLocationComponent> analysisTargetArg, IEnumerable<PhysicalLocationComponent> issueFileArg, string fullyQualifiedLogicalNameArg, IEnumerable<LogicalLocationComponent> logicalLocationArg, global::System.Collections.Generic.Dictionary<string, string> propertiesArg)
        {
            if (analysisTargetArg != null)
            {
                var destination_0 = new List<PhysicalLocationComponent>();
                if (analysisTargetArg != null)
                {
                    foreach (var value_0 in analysisTargetArg)
                    {
                        if (value_0 == null)
                        {
                            destination_0.Add(null);
                        }
                        else
                        {
                            destination_0.Add(new PhysicalLocationComponent(value_0));
                        }
                    }
                }

                this.AnalysisTarget = destination_0;
            }
            if (issueFileArg != null)
            {
                var destination_1 = new List<PhysicalLocationComponent>();
                if (issueFileArg != null)
                {
                    foreach (var value_1 in issueFileArg)
                    {
                        if (value_1 == null)
                        {
                            destination_1.Add(null);
                        }
                        else
                        {
                            destination_1.Add(new PhysicalLocationComponent(value_1));
                        }
                    }
                }

                this.IssueFile = destination_1;
            }
            if (fullyQualifiedLogicalNameArg != null)
            {
                this.FullyQualifiedLogicalName = fullyQualifiedLogicalNameArg;
            }
            if (logicalLocationArg != null)
            {
                var destination_2 = new List<LogicalLocationComponent>();
                if (logicalLocationArg != null)
                {
                    foreach (var value_2 in logicalLocationArg)
                    {
                        if (value_2 == null)
                        {
                            destination_2.Add(null);
                        }
                        else
                        {
                            destination_2.Add(new LogicalLocationComponent(value_2));
                        }
                    }
                }

                this.LogicalLocation = destination_2;
            }
            if (propertiesArg != null)
            {
                this.Properties = new global::System.Collections.Generic.Dictionary<string, string>(propertiesArg);
            }
        }

        /// <summary>Initializes a new instance of the <see cref="Location" /> class.</summary>
        public Location()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="Location" /> class with the supplied data.</summary>
        /// <param name="analysisTargetArg">An initialization value for the <see cref="P:AnalysisTarget" /> member.</param>
        /// <param name="issueFileArg">An initialization value for the <see cref="P:IssueFile" /> member.</param>
        /// <param name="fullyQualifiedLogicalNameArg">An initialization value for the <see cref="P:FullyQualifiedLogicalName" /> member.</param>
        /// <param name="logicalLocationArg">An initialization value for the <see cref="P:LogicalLocation" /> member.</param>
        /// <param name="propertiesArg">An initialization value for the <see cref="P:Properties" /> member.</param>
        public Location(IEnumerable<PhysicalLocationComponent> analysisTargetArg, IEnumerable<PhysicalLocationComponent> issueFileArg, string fullyQualifiedLogicalNameArg, IEnumerable<LogicalLocationComponent> logicalLocationArg, global::System.Collections.Generic.Dictionary<string, string> propertiesArg)
        {
            this.Init(
                analysisTargetArg, 
                issueFileArg, 
                fullyQualifiedLogicalNameArg, 
                logicalLocationArg, 
                propertiesArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="Location" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public Location(Location other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.AnalysisTarget, 
                other.IssueFile, 
                other.FullyQualifiedLogicalName, 
                other.LogicalLocation, 
                other.Properties
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public Location DeepClone()
        {
            return (Location)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new Location(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                foreach (var value_0 in this.AnalysisTarget)
                {
                    result = result * 31;
                    if (value_0 != null)
                    {
                        result = (result * 31) + value_0.GetHashCode();
                    }
                }

                foreach (var value_1 in this.IssueFile)
                {
                    result = result * 31;
                    if (value_1 != null)
                    {
                        result = (result * 31) + value_1.GetHashCode();
                    }
                }

                if (this.FullyQualifiedLogicalName != null)
                {
                    result = (result * 31) + this.FullyQualifiedLogicalName.GetHashCode();
                }
                foreach (var value_2 in this.LogicalLocation)
                {
                    result = result * 31;
                    if (value_2 != null)
                    {
                        result = (result * 31) + value_2.GetHashCode();
                    }
                }

                if (this.Properties != null)
                {
                    // Use xor for dictionaries to be order-independent
                    int xor_0 = 0;
                    foreach (var value_3 in this.Properties)
                    {
                        xor_0 ^= (value_3.Key ?? String.Empty).GetHashCode();
                        xor_0 ^= (value_3.Value ?? String.Empty).GetHashCode();
                    }

                    result = (result * 31) + xor_0;
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as Location);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(Location other)
        {
            if (other == null)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.AnalysisTarget, other.AnalysisTarget))
            {
                if (this.AnalysisTarget == null || other.AnalysisTarget == null)
                {
                    return false;
                }

                if (this.AnalysisTarget.Count != other.AnalysisTarget.Count)
                {
                    return false;
                }

                int max_0 = this.AnalysisTarget.Count;
                for (int index_0 = 0; index_0 < max_0; ++index_0)
                {
                    var value_4 = this.AnalysisTarget[index_0];
                    var value_5 = other.AnalysisTarget[index_0];
                    if (!global::System.Object.Equals(value_4, value_5))
                    {
                        return false;
                    }
                }
            }

            if (!global::System.Object.ReferenceEquals(this.IssueFile, other.IssueFile))
            {
                if (this.IssueFile == null || other.IssueFile == null)
                {
                    return false;
                }

                if (this.IssueFile.Count != other.IssueFile.Count)
                {
                    return false;
                }

                int max_1 = this.IssueFile.Count;
                for (int index_1 = 0; index_1 < max_1; ++index_1)
                {
                    var value_6 = this.IssueFile[index_1];
                    var value_7 = other.IssueFile[index_1];
                    if (!global::System.Object.Equals(value_6, value_7))
                    {
                        return false;
                    }
                }
            }

            if (this.FullyQualifiedLogicalName != other.FullyQualifiedLogicalName)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.LogicalLocation, other.LogicalLocation))
            {
                if (this.LogicalLocation == null || other.LogicalLocation == null)
                {
                    return false;
                }

                if (this.LogicalLocation.Count != other.LogicalLocation.Count)
                {
                    return false;
                }

                int max_2 = this.LogicalLocation.Count;
                for (int index_2 = 0; index_2 < max_2; ++index_2)
                {
                    var value_8 = this.LogicalLocation[index_2];
                    var value_9 = other.LogicalLocation[index_2];
                    if (!global::System.Object.Equals(value_8, value_9))
                    {
                        return false;
                    }
                }
            }

            if (!global::System.Object.ReferenceEquals(this.Properties, other.Properties))
            {
                if (this.Properties == null || other.Properties == null || this.Properties.Count != other.Properties.Count)
                {
                    return false;
                }
                foreach (var value_10 in this.Properties)
                {
                    string value_11;
                    if (!other.Properties.TryGetValue(value_10.Key, out value_11) || !global::System.Object.Equals(value_10.Value, value_11))
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }

    /// <summary>
    /// One level (e.g. namespace, function, etc.) of a logical location tree.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class LogicalLocationComponent : ISyntax, IEquatable<LogicalLocationComponent>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public ToolIssuesLogKind Kind { get { return ToolIssuesLogKind.LogicalLocationComponent; } }

        /// <summary>
        /// Name of the item specified by this location component.
        /// </summary>
        [DataMember(Name="name", IsRequired = true)]
        public string Name { get; set; }

        /// <summary>
        /// The type of item this location refers to.
        /// </summary>
        [DataMember(Name="locationKind", IsRequired = true)]
        public string LocationKind { get; set; }

        private void Init(string nameArg, string locationKindArg)
        {
            if (nameArg != null)
            {
                this.Name = nameArg;
            }
            if (locationKindArg != null)
            {
                this.LocationKind = locationKindArg;
            }
        }

        /// <summary>Initializes a new instance of the <see cref="LogicalLocationComponent" /> class.</summary>
        public LogicalLocationComponent()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="LogicalLocationComponent" /> class with the supplied data.</summary>
        /// <param name="nameArg">An initialization value for the <see cref="P:Name" /> member.</param>
        /// <param name="locationKindArg">An initialization value for the <see cref="P:LocationKind" /> member.</param>
        public LogicalLocationComponent(string nameArg, string locationKindArg)
        {
            this.Init(
                nameArg, 
                locationKindArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="LogicalLocationComponent" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public LogicalLocationComponent(LogicalLocationComponent other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.Name, 
                other.LocationKind
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public LogicalLocationComponent DeepClone()
        {
            return (LogicalLocationComponent)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new LogicalLocationComponent(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                if (this.Name != null)
                {
                    result = (result * 31) + this.Name.GetHashCode();
                }
                if (this.LocationKind != null)
                {
                    result = (result * 31) + this.LocationKind.GetHashCode();
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as LogicalLocationComponent);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(LogicalLocationComponent other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.Name != other.Name)
            {
                return false;
            }

            if (this.LocationKind != other.LocationKind)
            {
                return false;
            }

            return true;
        }
    }

    /// <summary>
    /// A part of a location that refers to a file.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class PhysicalLocationComponent : ISyntax, IEquatable<PhysicalLocationComponent>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public ToolIssuesLogKind Kind { get { return ToolIssuesLogKind.PhysicalLocationComponent; } }

        /// <summary>
        /// Uri to the file specified by this location.
        /// </summary>
        [DataMember(Name="uri", IsRequired = true)]
        public global::System.Uri Uri { get; set; }

        /// <summary>
        /// The MIME content type (RFC 2045) of the item refered to by this location.
        /// </summary>
        [DataMember(Name="mimeType", IsRequired = false, EmitDefaultValue = false)]
        public string MimeType { get; set; }

        /// <summary>
        /// The specific region within the analysis where the issue was detected. This SHOULD only be
        /// set on the last physicalLocationComponent in a physicalLocation most of the time.
        /// (There are some exceptions e.g. an embedded .SWF in an Office 2003 format ppt)
        /// </summary>
        [DataMember(Name="region", IsRequired = false, EmitDefaultValue = false)]
        public Region Region { get; set; }

        private void Init(global::System.Uri uriArg, string mimeTypeArg, Region regionArg)
        {
            if (uriArg != null)
            {
                this.Uri = new global::System.Uri(uriArg.OriginalString, uriArg.IsAbsoluteUri ? global::System.UriKind.Absolute : global::System.UriKind.Relative);
            }
            if (mimeTypeArg != null)
            {
                this.MimeType = mimeTypeArg;
            }
            if (regionArg != null)
            {
                this.Region = new Region(regionArg);
            }
        }

        /// <summary>Initializes a new instance of the <see cref="PhysicalLocationComponent" /> class.</summary>
        public PhysicalLocationComponent()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="PhysicalLocationComponent" /> class with the supplied data.</summary>
        /// <param name="uriArg">An initialization value for the <see cref="P:Uri" /> member.</param>
        /// <param name="mimeTypeArg">An initialization value for the <see cref="P:MimeType" /> member.</param>
        /// <param name="regionArg">An initialization value for the <see cref="P:Region" /> member.</param>
        public PhysicalLocationComponent(global::System.Uri uriArg, string mimeTypeArg, Region regionArg)
        {
            this.Init(
                uriArg, 
                mimeTypeArg, 
                regionArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="PhysicalLocationComponent" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public PhysicalLocationComponent(PhysicalLocationComponent other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.Uri, 
                other.MimeType, 
                other.Region
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public PhysicalLocationComponent DeepClone()
        {
            return (PhysicalLocationComponent)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new PhysicalLocationComponent(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                if (this.Uri != null)
                {
                    result = (result * 31) + this.Uri.GetHashCode();
                }
                if (this.MimeType != null)
                {
                    result = (result * 31) + this.MimeType.GetHashCode();
                }
                if (this.Region != null)
                {
                    result = (result * 31) + this.Region.GetHashCode();
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as PhysicalLocationComponent);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(PhysicalLocationComponent other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.Uri != other.Uri)
            {
                return false;
            }

            if (this.MimeType != other.MimeType)
            {
                return false;
            }

            if (!global::System.Object.Equals(this.Region, other.Region))
            {
                return false;
            }

            return true;
        }
    }

    /// <summary>
    /// Specifies a region within a file where an issue was detected.
    /// </summary>
    /// <remarks>
    /// Minimally, the Region should be populated with the StartLine or Offset members.
    /// There is some duplication of information in Region members. Log file producers
    /// are responsible for ensuring that any members populated in this type are
    /// consistent with each other (e.g., the file offset, if provided, should match the
    /// StartLine + EndColumn, if also provided). In the event that the type members are
    /// fully populated, viewers are free to choose whatever data is easiest to consume.
    /// </remarks>
    [DataContract]
    [CompilerGenerated]
    public sealed class Region : ISyntax, IEquatable<Region>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public ToolIssuesLogKind Kind { get { return ToolIssuesLogKind.Region; } }

        /// <summary>
        /// The starting line location associated with a region in the text file.
        /// </summary>
        [DataMember(Name="startLine", IsRequired = false, EmitDefaultValue = false)]
        public int StartLine { get; set; }

        /// <summary>
        /// The starting column location associated with a region in the text file.
        /// </summary>
        [DataMember(Name="startColumn", IsRequired = false, EmitDefaultValue = false)]
        public int StartColumn { get; set; }

        /// <summary>
        /// The ending line location associated with a region in the text file.
        /// </summary>
        [DataMember(Name="endLine", IsRequired = false, EmitDefaultValue = false)]
        public int EndLine { get; set; }

        /// <summary>
        /// The ending column location associated with a region in the text file.
        /// </summary>
        [DataMember(Name="endColumn", IsRequired = false, EmitDefaultValue = false)]
        public int EndColumn { get; set; }

        /// <summary>
        /// The zero-based offset into the file.
        /// </summary>
        [DataMember(Name="offset", IsRequired = false, EmitDefaultValue = false)]
        public int Offset { get; set; }

        /// <summary>
        /// The length of the region.
        /// </summary>
        [DataMember(Name="length", IsRequired = false, EmitDefaultValue = false)]
        public int Length { get; set; }

        private void Init(int startLineArg, int startColumnArg, int endLineArg, int endColumnArg, int offsetArg, int lengthArg)
        {
            this.StartLine = startLineArg;
            this.StartColumn = startColumnArg;
            this.EndLine = endLineArg;
            this.EndColumn = endColumnArg;
            this.Offset = offsetArg;
            this.Length = lengthArg;
        }

        /// <summary>Initializes a new instance of the <see cref="Region" /> class.</summary>
        public Region()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="Region" /> class with the supplied data.</summary>
        /// <param name="startLineArg">An initialization value for the <see cref="P:StartLine" /> member.</param>
        /// <param name="startColumnArg">An initialization value for the <see cref="P:StartColumn" /> member.</param>
        /// <param name="endLineArg">An initialization value for the <see cref="P:EndLine" /> member.</param>
        /// <param name="endColumnArg">An initialization value for the <see cref="P:EndColumn" /> member.</param>
        /// <param name="offsetArg">An initialization value for the <see cref="P:Offset" /> member.</param>
        /// <param name="lengthArg">An initialization value for the <see cref="P:Length" /> member.</param>
        public Region(int startLineArg, int startColumnArg, int endLineArg, int endColumnArg, int offsetArg, int lengthArg)
        {
            this.Init(
                startLineArg, 
                startColumnArg, 
                endLineArg, 
                endColumnArg, 
                offsetArg, 
                lengthArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="Region" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public Region(Region other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.StartLine, 
                other.StartColumn, 
                other.EndLine, 
                other.EndColumn, 
                other.Offset, 
                other.Length
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public Region DeepClone()
        {
            return (Region)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new Region(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                result = (result * 31) + (int)this.StartLine;
                result = (result * 31) + (int)this.StartColumn;
                result = (result * 31) + (int)this.EndLine;
                result = (result * 31) + (int)this.EndColumn;
                result = (result * 31) + (int)this.Offset;
                result = (result * 31) + (int)this.Length;
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as Region);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(Region other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.StartLine != other.StartLine)
            {
                return false;
            }

            if (this.StartColumn != other.StartColumn)
            {
                return false;
            }

            if (this.EndLine != other.EndLine)
            {
                return false;
            }

            if (this.EndColumn != other.EndColumn)
            {
                return false;
            }

            if (this.Offset != other.Offset)
            {
                return false;
            }

            if (this.Length != other.Length)
            {
                return false;
            }

            return true;
        }
    }

    /// <summary>
    /// A runInfo object describes the invocation of the static analysis tool that produced the issues
    /// specified in the containing runLog object (�6.4).
    /// NOTE: The information in the runInfo object makes it possible to precisely repeat a run of a
    /// static analysis tool, and to verify that the issues reported in the log file were generated
    /// by an appropriate invocation of the tool.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class RunInfo : ISyntax, IEquatable<RunInfo>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public ToolIssuesLogKind Kind { get { return ToolIssuesLogKind.RunInfo; } }

        /// <summary>
        /// A string containing the command line arguments with which the tool was invoked. This string
        /// shall not include the file name or path to the executable itself.
        /// </summary>
        [DataMember(Name="commandLineArguments", IsRequired = true)]
        public string CommandLineArguments { get; set; }

        /// <summary>
        /// An array, each of whose elements is a fileReference object (�6.7) representing the location of
        /// a single analysis target scanned during the run. This array shall contain one entry for each
        /// analysis target that was scanned, even if the analysis targets were not individually specified
        /// on the command line.
        /// NOTE 1: The command line with which the tool was invoked might specify its input files by means
        /// of a wild card such as *.cc, or it might specify them implicitly, for example, by scanning the
        /// files in the current directory.
        /// The analysisTargets array shall be empty if no analysis targets were scanned in the course of the run.
        /// NOTE 2: This could happen if the command line specified a wildcard such as *.cc for the input files,
        /// and no files matched the wildcard.
        /// </summary>
        [DataMember(Name="analysisTargets", IsRequired = true)]
        public IList<FileReference> AnalysisTargets { get; set; }

        private void Init(string commandLineArgumentsArg, IEnumerable<FileReference> analysisTargetsArg)
        {
            if (commandLineArgumentsArg != null)
            {
                this.CommandLineArguments = commandLineArgumentsArg;
            }
            if (analysisTargetsArg != null)
            {
                var destination_0 = new List<FileReference>();
                if (analysisTargetsArg != null)
                {
                    foreach (var value_0 in analysisTargetsArg)
                    {
                        if (value_0 == null)
                        {
                            destination_0.Add(null);
                        }
                        else
                        {
                            destination_0.Add(new FileReference(value_0));
                        }
                    }
                }

                this.AnalysisTargets = destination_0;
            }
        }

        /// <summary>Initializes a new instance of the <see cref="RunInfo" /> class.</summary>
        public RunInfo()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="RunInfo" /> class with the supplied data.</summary>
        /// <param name="commandLineArgumentsArg">An initialization value for the <see cref="P:CommandLineArguments" /> member.</param>
        /// <param name="analysisTargetsArg">An initialization value for the <see cref="P:AnalysisTargets" /> member.</param>
        public RunInfo(string commandLineArgumentsArg, IEnumerable<FileReference> analysisTargetsArg)
        {
            this.Init(
                commandLineArgumentsArg, 
                analysisTargetsArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="RunInfo" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public RunInfo(RunInfo other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.CommandLineArguments, 
                other.AnalysisTargets
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public RunInfo DeepClone()
        {
            return (RunInfo)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new RunInfo(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                if (this.CommandLineArguments != null)
                {
                    result = (result * 31) + this.CommandLineArguments.GetHashCode();
                }
                foreach (var value_0 in this.AnalysisTargets)
                {
                    result = result * 31;
                    if (value_0 != null)
                    {
                        result = (result * 31) + value_0.GetHashCode();
                    }
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as RunInfo);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(RunInfo other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.CommandLineArguments != other.CommandLineArguments)
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.AnalysisTargets, other.AnalysisTargets))
            {
                if (this.AnalysisTargets == null || other.AnalysisTargets == null)
                {
                    return false;
                }

                if (this.AnalysisTargets.Count != other.AnalysisTargets.Count)
                {
                    return false;
                }

                int max_0 = this.AnalysisTargets.Count;
                for (int index_0 = 0; index_0 < max_0; ++index_0)
                {
                    var value_1 = this.AnalysisTargets[index_0];
                    var value_2 = other.AnalysisTargets[index_0];
                    if (!global::System.Object.Equals(value_1, value_2))
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }

    [DataContract]
    [CompilerGenerated]
    public sealed class RunLog : ISyntax, IEquatable<RunLog>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public ToolIssuesLogKind Kind { get { return ToolIssuesLogKind.RunLog; } }

        /// <summary>
        /// Information about the tool or tool pipeline that generated the issues in this log. An issue
        /// log can only contain issues produced by a single tool or tool pipeline. An issue log can
        /// aggregate results from multiple tool log files, as long as context around the tool run
        /// (tool command-line arguments and the like) is identical for all aggregated files.
        /// </summary>
        [DataMember(Name="toolInfo", IsRequired = true)]
        public ToolInfo ToolInfo { get; set; }

        /// <summary>
        /// A runInfo object describes the invocation of the static analysis tool that produced the issues
        /// specified in the containing runLog object (�6.4).
        /// </summary>
        [DataMember(Name="runInfo", IsRequired = true)]
        public RunInfo RunInfo { get; set; }

        /// <summary>
        /// The set of issues contained in an SARIF log.
        /// </summary>
        [DataMember(Name="issues", IsRequired = true)]
        public IList<Issue> Issues { get; set; }

        private void Init(ToolInfo toolInfoArg, RunInfo runInfoArg, IEnumerable<Issue> issuesArg)
        {
            if (toolInfoArg != null)
            {
                this.ToolInfo = new ToolInfo(toolInfoArg);
            }
            if (runInfoArg != null)
            {
                this.RunInfo = new RunInfo(runInfoArg);
            }
            if (issuesArg != null)
            {
                var destination_0 = new List<Issue>();
                if (issuesArg != null)
                {
                    foreach (var value_0 in issuesArg)
                    {
                        if (value_0 == null)
                        {
                            destination_0.Add(null);
                        }
                        else
                        {
                            destination_0.Add(new Issue(value_0));
                        }
                    }
                }

                this.Issues = destination_0;
            }
        }

        /// <summary>Initializes a new instance of the <see cref="RunLog" /> class.</summary>
        public RunLog()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="RunLog" /> class with the supplied data.</summary>
        /// <param name="toolInfoArg">An initialization value for the <see cref="P:ToolInfo" /> member.</param>
        /// <param name="runInfoArg">An initialization value for the <see cref="P:RunInfo" /> member.</param>
        /// <param name="issuesArg">An initialization value for the <see cref="P:Issues" /> member.</param>
        public RunLog(ToolInfo toolInfoArg, RunInfo runInfoArg, IEnumerable<Issue> issuesArg)
        {
            this.Init(
                toolInfoArg, 
                runInfoArg, 
                issuesArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="RunLog" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public RunLog(RunLog other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.ToolInfo, 
                other.RunInfo, 
                other.Issues
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public RunLog DeepClone()
        {
            return (RunLog)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new RunLog(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                if (this.ToolInfo != null)
                {
                    result = (result * 31) + this.ToolInfo.GetHashCode();
                }
                if (this.RunInfo != null)
                {
                    result = (result * 31) + this.RunInfo.GetHashCode();
                }
                foreach (var value_0 in this.Issues)
                {
                    result = result * 31;
                    if (value_0 != null)
                    {
                        result = (result * 31) + value_0.GetHashCode();
                    }
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as RunLog);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(RunLog other)
        {
            if (other == null)
            {
                return false;
            }

            if (!global::System.Object.Equals(this.ToolInfo, other.ToolInfo))
            {
                return false;
            }

            if (!global::System.Object.Equals(this.RunInfo, other.RunInfo))
            {
                return false;
            }

            if (!global::System.Object.ReferenceEquals(this.Issues, other.Issues))
            {
                if (this.Issues == null || other.Issues == null)
                {
                    return false;
                }

                if (this.Issues.Count != other.Issues.Count)
                {
                    return false;
                }

                int max_0 = this.Issues.Count;
                for (int index_0 = 0; index_0 < max_0; ++index_0)
                {
                    var value_1 = this.Issues[index_0];
                    var value_2 = other.Issues[index_0];
                    if (!global::System.Object.Equals(value_1, value_2))
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }

    /// <summary>
    /// Information about the tool or tool pipeline that generated the issues in this log.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class ToolInfo : ISyntax, IEquatable<ToolInfo>
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public ToolIssuesLogKind Kind { get { return ToolIssuesLogKind.ToolInfo; } }

        /// <summary>
        /// The name of the tool or tool pipeline that generated the issues in this log, e.g., FxCop.
        /// </summary>
        [DataMember(Name="toolName", IsRequired = true)]
        public string ToolName { get; set; }

        /// <summary>
        /// An unformatted version string that can include additional, arbitrary details
        /// identifying the tool (such as build branch information, company details, etc.).
        /// </summary>
        [DataMember(Name="fullVersion", IsRequired = false, EmitDefaultValue = false)]
        public string FullVersion { get; set; }

        /// <summary>
        /// A version that refers to the tool as a whole (as opposed to, for example,
        /// the build version of an individual binary in the tool).
        /// </summary>
        [DataMember(Name="productVersion", IsRequired = false, EmitDefaultValue = false)]
        public string ProductVersion { get; set; }

        /// <summary>
        /// For Windows tools only, the binary version of the primary tool exe.
        /// </summary>
        [DataMember(Name="fileVersion", IsRequired = false, EmitDefaultValue = false)]
        public string FileVersion { get; set; }

        private void Init(string toolNameArg, string fullVersionArg, string productVersionArg, string fileVersionArg)
        {
            if (toolNameArg != null)
            {
                this.ToolName = toolNameArg;
            }
            if (fullVersionArg != null)
            {
                this.FullVersion = fullVersionArg;
            }
            if (productVersionArg != null)
            {
                this.ProductVersion = productVersionArg;
            }
            if (fileVersionArg != null)
            {
                this.FileVersion = fileVersionArg;
            }
        }

        /// <summary>Initializes a new instance of the <see cref="ToolInfo" /> class.</summary>
        public ToolInfo()
        {
            // Blank on purpose
        }

        /// <summary>Initializes a new instance of the <see cref="ToolInfo" /> class with the supplied data.</summary>
        /// <param name="toolNameArg">An initialization value for the <see cref="P:ToolName" /> member.</param>
        /// <param name="fullVersionArg">An initialization value for the <see cref="P:FullVersion" /> member.</param>
        /// <param name="productVersionArg">An initialization value for the <see cref="P:ProductVersion" /> member.</param>
        /// <param name="fileVersionArg">An initialization value for the <see cref="P:FileVersion" /> member.</param>
        public ToolInfo(string toolNameArg, string fullVersionArg, string productVersionArg, string fileVersionArg)
        {
            this.Init(
                toolNameArg, 
                fullVersionArg, 
                productVersionArg, 
                fileVersionArg
            );
        }

        /// <summary>Initializes a new instance of the <see cref="ToolInfo" /> class as a copy of another instance.</summary>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="other" /> is null.</exception>
        /// <param name="other">The instance to copy.</param>
        public ToolInfo(ToolInfo other)
        {
            if (other == null)
            {
                throw new ArgumentNullException("other");
            }

            this.Init(
                other.ToolName, 
                other.FullVersion, 
                other.ProductVersion, 
                other.FileVersion
            );
        }

        ISyntax ISyntax.DeepClone()
        {
            return this.DeepCloneCore();
        }

        /// <summary>Creates a deep copy of this instance.</summary>
        public ToolInfo DeepClone()
        {
            return (ToolInfo)this.DeepCloneCore();
        }

        private ISyntax DeepCloneCore()
        {
            return new ToolInfo(this);
        }

        /// <summary>Generates a hash code for this instance.</summary>
        /// <returns>A hash code for this instance; suitable for putting this instance into a hashtable.</returns>
        public override int GetHashCode()
        {
            int result = 17;
            unchecked
            {
                if (this.ToolName != null)
                {
                    result = (result * 31) + this.ToolName.GetHashCode();
                }
                if (this.FullVersion != null)
                {
                    result = (result * 31) + this.FullVersion.GetHashCode();
                }
                if (this.ProductVersion != null)
                {
                    result = (result * 31) + this.ProductVersion.GetHashCode();
                }
                if (this.FileVersion != null)
                {
                    result = (result * 31) + this.FileVersion.GetHashCode();
                }
            }

            return result;
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="o">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="o" /> contain the same data; otherwise, false.</returns>
        public override bool Equals(object o)
        {
            return this.Equals(o as ToolInfo);
        }

        /// <summary>Compares this instance with another instance.</summary>
        /// <param name="other">The instance to compare with this instance.</param>
        /// <returns>true if this instance and <paramref name="other" /> contain the same data; otherwise, false.</returns>
        public bool Equals(ToolInfo other)
        {
            if (other == null)
            {
                return false;
            }

            if (this.ToolName != other.ToolName)
            {
                return false;
            }

            if (this.FullVersion != other.FullVersion)
            {
                return false;
            }

            if (this.ProductVersion != other.ProductVersion)
            {
                return false;
            }

            if (this.FileVersion != other.FileVersion)
            {
                return false;
            }

            return true;
        }
    }

    /// <summary>Visitor for a ToolIssuesLog tree.</summary>
    public abstract class ToolIssuesLogVisitor<T>
    {
        /// <summary>Starts a visit of a ToolIssuesLog tree.</summary>
        /// <param name="node">The node to visit.</param>
        public virtual T Visit(ISyntax node)
        {
            return this.VisitActual(node);
        }

        /// <summary>Executes a visit of a ToolIssuesLog tree.</summary>
        /// <param name="node">The node to visit.</param>
        public virtual T VisitActual(ISyntax node)
        {
            if (node == null)
            {
                throw new ArgumentNullException("node");
            }

            switch (node.Kind)
            {
            case ToolIssuesLogKind.ExecutionFlowEntry:
                return this.VisitExecutionFlowEntry((ExecutionFlowEntry)node);
            case ToolIssuesLogKind.FileReference:
                return this.VisitFileReference((FileReference)node);
            case ToolIssuesLogKind.Hash:
                return this.VisitHash((Hash)node);
            case ToolIssuesLogKind.Issue:
                return this.VisitIssue((Issue)node);
            case ToolIssuesLogKind.IssueLog:
                return this.VisitIssueLog((IssueLog)node);
            case ToolIssuesLogKind.Location:
                return this.VisitLocation((Location)node);
            case ToolIssuesLogKind.LogicalLocationComponent:
                return this.VisitLogicalLocationComponent((LogicalLocationComponent)node);
            case ToolIssuesLogKind.PhysicalLocationComponent:
                return this.VisitPhysicalLocationComponent((PhysicalLocationComponent)node);
            case ToolIssuesLogKind.Region:
                return this.VisitRegion((Region)node);
            case ToolIssuesLogKind.RunInfo:
                return this.VisitRunInfo((RunInfo)node);
            case ToolIssuesLogKind.RunLog:
                return this.VisitRunLog((RunLog)node);
            case ToolIssuesLogKind.ToolInfo:
                return this.VisitToolInfo((ToolInfo)node);
            default:
                return (T)(object)node;
            }
        }

        private void VisitNullChecked(ISyntax node)
        {
            if (node != null)
            {
                this.Visit(node);
            }
        }

        /// <summary>Visits a ExecutionFlowEntry node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A ExecutionFlowEntry node to visit.</param>
        public virtual T VisitExecutionFlowEntry(ExecutionFlowEntry node)
        {
            if (node != null)
            {
                if (node.PhysicalLocations != null)
                {
                    foreach (var value_0 in node.PhysicalLocations)
                    {
                        if (value_0 != null)
                        {
                            foreach (var value_1 in value_0)
                            {
                                this.VisitNullChecked(value_1);
                            }
                        }
                    }
                }

            }

            return (T)(object)node;
        }

        /// <summary>Visits a FileReference node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A FileReference node to visit.</param>
        public virtual T VisitFileReference(FileReference node)
        {
            if (node != null)
            {
                if (node.Hashes != null)
                {
                    foreach (var value_0 in node.Hashes)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

            }

            return (T)(object)node;
        }

        /// <summary>Visits a Hash node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A Hash node to visit.</param>
        public virtual T VisitHash(Hash node)
        {
            if (node != null)
            {
            }

            return (T)(object)node;
        }

        /// <summary>Visits a Issue node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A Issue node to visit.</param>
        public virtual T VisitIssue(Issue node)
        {
            if (node != null)
            {
                if (node.Locations != null)
                {
                    foreach (var value_0 in node.Locations)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

                if (node.Stacks != null)
                {
                    foreach (var value_0 in node.Stacks)
                    {
                        if (value_0 != null)
                        {
                            foreach (var value_1 in value_0)
                            {
                                this.VisitNullChecked(value_1);
                            }
                        }
                    }
                }

                if (node.ExecutionFlows != null)
                {
                    foreach (var value_0 in node.ExecutionFlows)
                    {
                        if (value_0 != null)
                        {
                            foreach (var value_1 in value_0)
                            {
                                this.VisitNullChecked(value_1);
                            }
                        }
                    }
                }

            }

            return (T)(object)node;
        }

        /// <summary>Visits a IssueLog node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A IssueLog node to visit.</param>
        public virtual T VisitIssueLog(IssueLog node)
        {
            if (node != null)
            {
                if (node.RunLogs != null)
                {
                    foreach (var value_0 in node.RunLogs)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

            }

            return (T)(object)node;
        }

        /// <summary>Visits a Location node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A Location node to visit.</param>
        public virtual T VisitLocation(Location node)
        {
            if (node != null)
            {
                if (node.AnalysisTarget != null)
                {
                    foreach (var value_0 in node.AnalysisTarget)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

                if (node.IssueFile != null)
                {
                    foreach (var value_0 in node.IssueFile)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

                if (node.LogicalLocation != null)
                {
                    foreach (var value_0 in node.LogicalLocation)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

            }

            return (T)(object)node;
        }

        /// <summary>Visits a LogicalLocationComponent node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A LogicalLocationComponent node to visit.</param>
        public virtual T VisitLogicalLocationComponent(LogicalLocationComponent node)
        {
            if (node != null)
            {
            }

            return (T)(object)node;
        }

        /// <summary>Visits a PhysicalLocationComponent node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A PhysicalLocationComponent node to visit.</param>
        public virtual T VisitPhysicalLocationComponent(PhysicalLocationComponent node)
        {
            if (node != null)
            {
                this.VisitNullChecked(node.Region);
            }

            return (T)(object)node;
        }

        /// <summary>Visits a Region node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A Region node to visit.</param>
        public virtual T VisitRegion(Region node)
        {
            if (node != null)
            {
            }

            return (T)(object)node;
        }

        /// <summary>Visits a RunInfo node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A RunInfo node to visit.</param>
        public virtual T VisitRunInfo(RunInfo node)
        {
            if (node != null)
            {
                if (node.AnalysisTargets != null)
                {
                    foreach (var value_0 in node.AnalysisTargets)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

            }

            return (T)(object)node;
        }

        /// <summary>Visits a RunLog node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A RunLog node to visit.</param>
        public virtual T VisitRunLog(RunLog node)
        {
            if (node != null)
            {
                this.VisitNullChecked(node.ToolInfo);
                this.VisitNullChecked(node.RunInfo);
                if (node.Issues != null)
                {
                    foreach (var value_0 in node.Issues)
                    {
                        this.VisitNullChecked(value_0);
                    }
                }

            }

            return (T)(object)node;
        }

        /// <summary>Visits a ToolInfo node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A ToolInfo node to visit.</param>
        public virtual T VisitToolInfo(ToolInfo node)
        {
            if (node != null)
            {
            }

            return (T)(object)node;
        }
    }
    /// <summary>Rewriting visitor for a ToolIssuesLog tree.</summary>
    public abstract class ToolIssuesLogRewritingVisitor
    {
        /// <summary>Starts a rewriting visit of a ToolIssuesLog tree.</summary>
        /// <param name="node">The node to rewrite.</param>
        public virtual object Visit(ISyntax node)
        {
            return this.VisitActual(node);
        }

        /// <summary>Executes a visit of a ToolIssuesLog tree.</summary>
        /// <param name="node">The node to visit.</param>
        public virtual object VisitActual(ISyntax node)
        {
            if (node == null)
            {
                throw new ArgumentNullException("node");
            }

            switch (node.Kind)
            {
            case ToolIssuesLogKind.ExecutionFlowEntry:
                return this.VisitExecutionFlowEntry((ExecutionFlowEntry)node);
            case ToolIssuesLogKind.FileReference:
                return this.VisitFileReference((FileReference)node);
            case ToolIssuesLogKind.Hash:
                return this.VisitHash((Hash)node);
            case ToolIssuesLogKind.Issue:
                return this.VisitIssue((Issue)node);
            case ToolIssuesLogKind.IssueLog:
                return this.VisitIssueLog((IssueLog)node);
            case ToolIssuesLogKind.Location:
                return this.VisitLocation((Location)node);
            case ToolIssuesLogKind.LogicalLocationComponent:
                return this.VisitLogicalLocationComponent((LogicalLocationComponent)node);
            case ToolIssuesLogKind.PhysicalLocationComponent:
                return this.VisitPhysicalLocationComponent((PhysicalLocationComponent)node);
            case ToolIssuesLogKind.Region:
                return this.VisitRegion((Region)node);
            case ToolIssuesLogKind.RunInfo:
                return this.VisitRunInfo((RunInfo)node);
            case ToolIssuesLogKind.RunLog:
                return this.VisitRunLog((RunLog)node);
            case ToolIssuesLogKind.ToolInfo:
                return this.VisitToolInfo((ToolInfo)node);
            default:
                return node;
            }
        }

        private T VisitNullChecked<T>(T node)
            where T : class, ISyntax
        {
            if (node == null)
            {
                return null;
            }

            return (T)this.Visit(node);
        }

        /// <summary>Rewrites a ExecutionFlowEntry node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A ExecutionFlowEntry node to visit.</param>
        public virtual ExecutionFlowEntry VisitExecutionFlowEntry(ExecutionFlowEntry node)
        {
            if (node != null)
            {
                if (node.PhysicalLocations != null)
                {
                    for (int index_0 = 0; index_0 < node.PhysicalLocations.Count; ++index_0)
                    {
                        var value_0 = node.PhysicalLocations[index_0];
                        if (value_0 != null)
                        {
                            for (int index_1 = 0; index_1 < value_0.Count; ++index_1)
                            {
                                value_0[index_1] = this.VisitNullChecked(value_0[index_1]);
                            }
                        }
                    }
                }

            }

            return node;
        }

        /// <summary>Rewrites a FileReference node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A FileReference node to visit.</param>
        public virtual FileReference VisitFileReference(FileReference node)
        {
            if (node != null)
            {
                if (node.Hashes != null)
                {
                    for (int index_0 = 0; index_0 < node.Hashes.Count; ++index_0)
                    {
                        node.Hashes[index_0] = this.VisitNullChecked(node.Hashes[index_0]);
                    }
                }

            }

            return node;
        }

        /// <summary>Rewrites a Hash node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A Hash node to visit.</param>
        public virtual Hash VisitHash(Hash node)
        {
            if (node != null)
            {
            }

            return node;
        }

        /// <summary>Rewrites a Issue node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A Issue node to visit.</param>
        public virtual Issue VisitIssue(Issue node)
        {
            if (node != null)
            {
                if (node.Locations != null)
                {
                    for (int index_0 = 0; index_0 < node.Locations.Count; ++index_0)
                    {
                        node.Locations[index_0] = this.VisitNullChecked(node.Locations[index_0]);
                    }
                }

                if (node.Stacks != null)
                {
                    for (int index_0 = 0; index_0 < node.Stacks.Count; ++index_0)
                    {
                        var value_0 = node.Stacks[index_0];
                        if (value_0 != null)
                        {
                            for (int index_1 = 0; index_1 < value_0.Count; ++index_1)
                            {
                                value_0[index_1] = this.VisitNullChecked(value_0[index_1]);
                            }
                        }
                    }
                }

                if (node.ExecutionFlows != null)
                {
                    for (int index_0 = 0; index_0 < node.ExecutionFlows.Count; ++index_0)
                    {
                        var value_0 = node.ExecutionFlows[index_0];
                        if (value_0 != null)
                        {
                            for (int index_1 = 0; index_1 < value_0.Count; ++index_1)
                            {
                                value_0[index_1] = this.VisitNullChecked(value_0[index_1]);
                            }
                        }
                    }
                }

            }

            return node;
        }

        /// <summary>Rewrites a IssueLog node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A IssueLog node to visit.</param>
        public virtual IssueLog VisitIssueLog(IssueLog node)
        {
            if (node != null)
            {
                if (node.RunLogs != null)
                {
                    for (int index_0 = 0; index_0 < node.RunLogs.Count; ++index_0)
                    {
                        node.RunLogs[index_0] = this.VisitNullChecked(node.RunLogs[index_0]);
                    }
                }

            }

            return node;
        }

        /// <summary>Rewrites a Location node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A Location node to visit.</param>
        public virtual Location VisitLocation(Location node)
        {
            if (node != null)
            {
                if (node.AnalysisTarget != null)
                {
                    for (int index_0 = 0; index_0 < node.AnalysisTarget.Count; ++index_0)
                    {
                        node.AnalysisTarget[index_0] = this.VisitNullChecked(node.AnalysisTarget[index_0]);
                    }
                }

                if (node.IssueFile != null)
                {
                    for (int index_0 = 0; index_0 < node.IssueFile.Count; ++index_0)
                    {
                        node.IssueFile[index_0] = this.VisitNullChecked(node.IssueFile[index_0]);
                    }
                }

                if (node.LogicalLocation != null)
                {
                    for (int index_0 = 0; index_0 < node.LogicalLocation.Count; ++index_0)
                    {
                        node.LogicalLocation[index_0] = this.VisitNullChecked(node.LogicalLocation[index_0]);
                    }
                }

            }

            return node;
        }

        /// <summary>Rewrites a LogicalLocationComponent node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A LogicalLocationComponent node to visit.</param>
        public virtual LogicalLocationComponent VisitLogicalLocationComponent(LogicalLocationComponent node)
        {
            if (node != null)
            {
            }

            return node;
        }

        /// <summary>Rewrites a PhysicalLocationComponent node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A PhysicalLocationComponent node to visit.</param>
        public virtual PhysicalLocationComponent VisitPhysicalLocationComponent(PhysicalLocationComponent node)
        {
            if (node != null)
            {
                node.Region = this.VisitNullChecked(node.Region);
            }

            return node;
        }

        /// <summary>Rewrites a Region node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A Region node to visit.</param>
        public virtual Region VisitRegion(Region node)
        {
            if (node != null)
            {
            }

            return node;
        }

        /// <summary>Rewrites a RunInfo node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A RunInfo node to visit.</param>
        public virtual RunInfo VisitRunInfo(RunInfo node)
        {
            if (node != null)
            {
                if (node.AnalysisTargets != null)
                {
                    for (int index_0 = 0; index_0 < node.AnalysisTargets.Count; ++index_0)
                    {
                        node.AnalysisTargets[index_0] = this.VisitNullChecked(node.AnalysisTargets[index_0]);
                    }
                }

            }

            return node;
        }

        /// <summary>Rewrites a RunLog node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A RunLog node to visit.</param>
        public virtual RunLog VisitRunLog(RunLog node)
        {
            if (node != null)
            {
                node.ToolInfo = this.VisitNullChecked(node.ToolInfo);
                node.RunInfo = this.VisitNullChecked(node.RunInfo);
                if (node.Issues != null)
                {
                    for (int index_0 = 0; index_0 < node.Issues.Count; ++index_0)
                    {
                        node.Issues[index_0] = this.VisitNullChecked(node.Issues[index_0]);
                    }
                }

            }

            return node;
        }

        /// <summary>Rewrites a ToolInfo node in a ToolIssuesLog tree.</summary>
        /// <param name="node">A ToolInfo node to visit.</param>
        public virtual ToolInfo VisitToolInfo(ToolInfo node)
        {
            if (node != null)
            {
            }

            return node;
        }
    }
}
// End of generated code.

